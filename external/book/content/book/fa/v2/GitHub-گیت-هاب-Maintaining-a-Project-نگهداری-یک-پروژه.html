---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: fa
  chapter:
    title: GitHub (گیت هاب)
    number: 6
  section:
    title: Maintaining a Project (نگهداری یک پروژه)
    number: 3
    cs_number: '6.3'
    previous: book/fa/v2/GitHub-گیت-هاب-Contributing-to-a-Project-مشارکت-در-یک-پروژه
    next: book/fa/v2/GitHub-گیت-هاب-Managing-an-organization-مدیریت-یک-سازمان
title: Git - Maintaining a Project (نگهداری یک پروژه)
url: "/book/fa/v2/GitHub-گیت-هاب-Maintaining-a-Project-نگهداری-یک-پروژه.html"
---
<h2 id="_maintaining_gh_project">Maintaining a Project (نگهداری یک پروژه)</h2>
<div class="paragraph">
<p>حالا که با مشارکت در یک پروژه راحت شدیم، بیایید نگاهی به سمت دیگر ماجرا بیندازیم: ایجاد، نگهداری و مدیریت پروژه‌ی خودتان.</p>
</div>
<div class="sect3">
<h3 id="_creating_a_new_repository_ساخت_یک_ریپازیتوری">Creating a New Repository (ساخت یک ریپازیتوری)</h3>
<div class="paragraph">
<p>بیایید یک مخزن جدید بسازیم تا کد پروژه‌مان را با دیگران به اشتراک بگذاریم.
برای شروع، روی دکمه‌ی «New repository» در سمت راست داشبورد کلیک کنید، یا از دکمه‌ی + که کنار نام کاربری‌تان در نوار ابزار بالاست استفاده کنید، همان‌طور که در <a href="{{< relurl "book/fa/v2/ch00/_new_repo_dropdown" >}}">The “New repository” dropdown.</a> مشاهده می‌شود.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/fa/v2/images/newrepo.png" >}}" alt="The ``Your repositories'' area.">
</div>
<div class="title">نمودار 108. The “Your repositories” area.</div>
</div>
<div id="_new_repo_dropdown" class="imageblock">
<div class="content">
<img src="{{< relurl "book/fa/v2/images/new-repo.png" >}}" alt="The ``new repository'' dropdown.">
</div>
<div class="title">نمودار 109. The “New repository” dropdown.</div>
</div>
<div class="paragraph">
<p>این شما را به فرم «new repository» هدایت می‌کند:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/fa/v2/images/newrepoform.png" >}}" alt="The ``new repository'' form.">
</div>
<div class="title">نمودار 110. The “new repository” form.</div>
</div>
<div class="paragraph">
<p>در اینجا تنها کاری که باید انجام دهید، وارد کردن نام پروژه است؛ بقیه فیلدها کاملاً اختیاری هستند.
فعلاً فقط روی دکمه «Create Repository» کلیک کنید، و به همین راحتی — یک مخزن جدید در گیت‌هاب با نام <code>&lt;user&gt;/&lt;project_name&gt;</code> ساخته می‌شود.</p>
</div>
<div class="paragraph">
<p>از آنجایی که هنوز کدی در این مخزن وجود ندارد، گیت‌هاب راهنمایی‌هایی برای ایجاد یک مخزن گیت جدید یا اتصال به یک پروژه گیت موجود به شما نشان می‌دهد.
ما اینجا زیاد وارد جزئیات نمی‌شویم؛ اگر نیاز به یادآوری دارید، به <a href="{{< relurl "book/fa/v2/ch00/ch02-git-basics-chapter" >}}">مقدمات گیت</a> مراجعه کنید.</p>
</div>
<div class="paragraph">
<p>حالا که پروژه‌ی شما روی گیت‌هاب میزبانی می‌شود، می‌توانید آدرس آن را به هر کسی که می‌خواهید برای اشتراک‌گذاری پروژه بدهید.
هر پروژه در گیت‌هاب از طریق HTTPS به آدرس <code>https://github.com/&lt;user&gt;/&lt;project_name&gt;</code> و از طریق SSH به آدرس <code>git@github.com:&lt;user&gt;/&lt;project_name&gt;</code> قابل دسترسی است.
گیت می‌تواند هم از این دو آدرس دریافت (fetch) و ارسال (push) انجام دهد، اما دسترسی بر اساس مجوزهای کاربری که متصل می‌شود کنترل می‌شود.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">یادداشت</div>
</td>
<td class="content">
<div class="paragraph">
<p>معمولاً بهتر است برای پروژه‌های عمومی، آدرس مبتنی بر HTTPS را به اشتراک بگذارید، چون کاربران برای کلون کردن آن نیازی به داشتن حساب کاربری گیت‌هاب ندارند.
اگر آدرس SSH را بدهید، کاربران باید حساب کاربری گیت‌هاب داشته باشند و کلید SSH خود را بارگذاری کرده باشند تا به پروژه شما دسترسی پیدا کنند.
همچنین آدرس HTTPS دقیقاً همان آدرسی است که کاربران می‌توانند در مرورگر خود وارد کنند و پروژه را به صورت آنلاین مشاهده کنند.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h3 id="_adding_collaborators_افزودن_همکاران">Adding Collaborators (افزودن همکاران)</h3>
<div class="paragraph">
<p>اگر با افراد دیگری کار می‌کنید و می‌خواهید به آن‌ها اجازه‌ی commit زدن بدهید، باید آن‌ها را به‌عنوان «collaborators» اضافه کنید.
اگر بن، جف و لوئیز حساب‌های کاربری گیت‌هاب بسازند و شما بخواهید دسترسی push به مخزن خود به آن‌ها بدهید، می‌توانید آن‌ها را به پروژه اضافه کنید.
این کار به آن‌ها دسترسی «push» می‌دهد، یعنی هم اجازه خواندن و هم نوشتن روی پروژه و مخزن گیت را خواهند داشت.</p>
</div>
<div class="paragraph">
<p>برای این کار، روی لینک «Settings» در پایین نوار کناری سمت راست کلیک کنید.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/fa/v2/images/reposettingslink.png" >}}" alt="The repository settings link.">
</div>
<div class="title">نمودار 111. The repository settings link.</div>
</div>
<div class="paragraph">
<p>سپس از منوی سمت چپ گزینه‌ی «Collaborators» را انتخاب کنید.
بعد، نام کاربری (username) مورد نظر را در کادر وارد کنید و روی «Add collaborator» کلیک کنید.
می‌توانید این کار را هر تعداد که بخواهید تکرار کنید تا به همه کسانی که می‌خواهید دسترسی بدهید.
اگر نیاز داشتید دسترسی کسی را لغو کنید، کافی است روی علامت «X» سمت راست ردیف آن فرد کلیک کنید.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/fa/v2/images/collaborators.png" >}}" alt="The repository collaborators box.">
</div>
<div class="title">نمودار 112. Repository collaborators.</div>
</div>
</div>
<div class="sect3">
<h3 id="_managing_pull_requests_مدیریت_pull_request_ها">Managing Pull Requests (مدیریت Pull Request ها)</h3>
<div class="paragraph">
<p>حالا که یک پروژه با چند خط کد دارید و شاید چند همکار که دسترسی push دارند، بیایید ببینیم وقتی یک Pull Request دریافت می‌کنید، چه کاری باید انجام دهید.</p>
</div>
<div class="paragraph">
<p>Pull Requestها ممکن است از یک شاخه (branch) در یک fork از مخزن شما باشند، یا از یک شاخه‌ی دیگر در همان مخزن.
تفاوت اصلی این است که در fork معمولاً افراد نمی‌توانند روی شاخه‌ی شما push کنند و شما هم نمی‌توانید روی شاخه‌ی آن‌ها push کنید، اما در Pull Requestهای داخلی معمولاً هر دو طرف به شاخه دسترسی دارند.</p>
</div>
<div class="paragraph">
<p>برای این مثال‌ها، فرض کنیم شما با نام کاربری «tonychacon» هستید و یک پروژه‌ی جدید کد Arduino به نام «fade» ایجاد کرده‌اید.</p>
</div>
<div class="sect4">
<h4 id="_email_notifications">Email Notifications (اعلانات ایمیل)</h4>
<div class="paragraph">
<p>شخصی تغییراتی در کد شما ایجاد می‌کند و یک Pull Request برایتان ارسال می‌کند.
شما باید ایمیلی دریافت کنید که درباره‌ی Pull Request جدید اطلاع‌رسانی می‌کند و این ایمیل باید چیزی شبیه به <a href="{{< relurl "book/fa/v2/ch00/_email_pr" >}}">[_email_pr]</a> باشد.</p>
</div>
<div id="_email_pr" class="paragraph">
<p>ایمیل اطلاع‌رسانی درباره‌ی یک Pull Request جدید.
image::images/maint-01-email.png[Pull Request email notification]</p>
</div>
<div class="paragraph">
<p>چند نکته مهم در این ایمیل وجود دارد:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>یک diffstat کوچک به شما نشان می‌دهد — یعنی فهرستی از فایل‌هایی که در Pull Request تغییر کرده‌اند و میزان تغییرات هر کدام.</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>لینک مستقیمی به Pull Request روی گیت‌هاب دارد.</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>چند آدرس URL هم به شما می‌دهد که می‌توانید از خط فرمان استفاده کنید.</pre>
</div>
</div>
<div class="paragraph">
<p>اگر به خطی که می‌گوید git pull &lt;url&gt; patch-1 دقت کنید، این یک روش ساده برای ادغام (merge) یک شاخه‌ی راه دور (remote branch) است بدون اینکه نیاز باشد ریموت جدیدی اضافه کنید.
ما این موضوع را به‌صورت مختصر در <a href="{{< relurl "book/fa/v2/ch00/_checking_out_remotes" >}}">چک‌اوت کردن برنچ‌های ریموت</a> بررسی کردیم.
اگر بخواهید، می‌توانید ابتدا یک شاخه موضوعی (topic branch) بسازید و به آن سوییچ کنید، سپس این دستور را اجرا کنید تا تغییرات Pull Request را ادغام کنید.</p>
</div>
<div class="paragraph">
<p>آدرس‌های جالب دیگر، URLهای .diff و .patch هستند که همان‌طور که حدس می‌زنید، نسخه‌های unified diff و patch از Pull Request را فراهم می‌کنند.
از لحاظ فنی می‌توانید با چیزی شبیه به این هم کار ادغام Pull Request را انجام دهید:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ curl https://github.com/tonychacon/fade/pull/1.patch | git am</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h4 id="_collaborating_on_the_pull_request_همکاری_روی_pull_request">Collaborating on the Pull Request (همکاری روی Pull Request)</h4>
<div class="paragraph">
<p>همان‌طور که در <a href="{{< relurl "book/fa/v2/ch00/ch06-github_flow" >}}">The GitHub Flow (جریان کاری گیتهاب)</a> توضیح دادیم، حالا می‌توانید با فردی که Pull Request را باز کرده وارد گفتگو شوید.
می‌توانید روی خطوط خاصی از کد نظر بگذارید، روی کامیت‌های کامل کامنت بگذارید یا درباره کل Pull Request صحبت کنید، و در تمام این موارد می‌توانید از Markdown مخصوص گیت‌هاب استفاده کنید.</p>
</div>
<div class="paragraph">
<p>هر بار که کسی روی Pull Request نظر بگذارد، شما ایمیل اطلاع‌رسانی دریافت خواهید کرد تا از فعالیت‌ها مطلع باشید.
هر ایمیل شامل لینکی به همان Pull Request است که فعالیت در آن انجام شده و همچنین می‌توانید مستقیماً از طریق پاسخ به همان ایمیل در همان رشته‌ی گفتگو نظر دهید.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/fa/v2/images/maint-03-email-resp.png" >}}" alt="Email response">
</div>
<div class="title">نمودار 113. Responses to emails are included in the thread.</div>
</div>
<div class="paragraph">
<p>وقتی کد به جایی رسید که از آن راضی هستید و می‌خواهید آن را ادغام کنید، می‌توانید کد را دانلود کرده و به صورت محلی ادغام کنید، یا با استفاده از دستور git pull &lt;url&gt; &lt;branch&gt; که قبلاً دیدیم، یا با اضافه کردن fork به‌عنوان یک ریموت و سپس fetch و merge کردن.</p>
</div>
<div class="paragraph">
<p>اگر ادغام ساده و بدون تعارض باشد، می‌توانید مستقیماً روی دکمه «Merge» در سایت گیت‌هاب کلیک کنید.
این عملیات یک ادغام «non-fast-forward» انجام می‌دهد و حتی اگر امکان fast-forward merge وجود داشته باشد، یک commit ادغام (merge commit) ایجاد می‌کند.
به این معنی که هر بار دکمه merge را بزنید، یک commit ادغام ساخته می‌شود.
همانطور که در <a href="{{< relurl "book/fa/v2/ch00/_merge_button" >}}">Merge button and instructions for merging a Pull Request manually.</a> می‌بینید، گیت‌هاب تمام این اطلاعات را وقتی روی لینک راهنما کلیک می‌کنید، به شما نشان می‌دهد.</p>
</div>
<div id="_merge_button" class="imageblock">
<div class="content">
<img src="{{< relurl "book/fa/v2/images/maint-02-merge.png" >}}" alt="Merge button">
</div>
<div class="title">نمودار 114. Merge button and instructions for merging a Pull Request manually.</div>
</div>
<div class="paragraph">
<p>اگر تصمیم گرفتید که نمی‌خواهید ادغام کنید، می‌توانید به سادگی Pull Request را ببندید و فردی که آن را باز کرده است، از این موضوع مطلع خواهد شد.</p>
</div>
</div>
<div class="sect4">
<h4 id="_pr_refs">Pull Request Refs (رفرنس‌های Pull Request)</h4>
<div class="paragraph">
<p>اگر با تعداد زیادی Pull Request سر و کار دارید و نمی‌خواهید برای هر بار گرفتن تغییرات، ریموت‌های زیادی اضافه کنید یا هر بار pull انجام دهید، یک ترفند جالب وجود دارد که گیت‌هاب به شما اجازه می‌دهد انجام دهید.
این یک ترفند پیشرفته‌تر است و جزئیات بیشتری درباره آن در <a href="{{< relurl "book/fa/v2/ch00/_refspec" >}}">[_refspec]</a> خواهیم گفت، اما می‌تواند بسیار کاربردی باشد.</p>
</div>
<div class="paragraph">
<p>در واقع گیت‌هاب شاخه‌های Pull Request را به صورت شاخه‌های شبه‌مستقل (pseudo-branches) روی سرور نمایش می‌دهد.
به طور پیش‌فرض این شاخه‌ها هنگام کلون کردن دریافت نمی‌شوند، اما به شکلی مخفی وجود دارند و شما می‌توانید به راحتی به آن‌ها دسترسی پیدا کنید.</p>
</div>
<div class="paragraph">
<p>برای نشان دادن این موضوع، از یک دستور سطح پایین (که اغلب به آن دستور «plumbing» گفته می‌شود و در <a href="{{< relurl "book/fa/v2/ch00/_plumbing_porcelain" >}}">[_plumbing_porcelain]</a> بیشتر درباره‌اش می‌خوانیم) به نام ls-remote استفاده می‌کنیم.
این دستور معمولاً در عملیات روزمره گیت استفاده نمی‌شود، اما برای نمایش رفرنس‌های موجود روی سرور کاربردی است.</p>
</div>
<div class="paragraph">
<p>اگر این دستور را روی مخزن «blink» که قبلاً استفاده کردیم اجرا کنیم، فهرستی از تمام شاخه‌ها، تگ‌ها و سایر رفرنس‌ها در مخزن دریافت خواهیم کرد.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git ls-remote https://github.com/schacon/blink
10d539600d86723087810ec636870a504f4fee4d	HEAD
10d539600d86723087810ec636870a504f4fee4d	refs/heads/master
6a83107c62950be9453aac297bb0193fd743cd6e	refs/pull/1/head
afe83c2d1a70674c9505cc1d8b7d380d5e076ed3	refs/pull/1/merge
3c8d735ee16296c242be7a9742ebfbc2665adec1	refs/pull/2/head
15c9f4f80973a2758462ab2066b6ad9fe8dcf03d	refs/pull/2/merge
a5a7751a33b7e86c5e9bb07b26001bb17d775d1a	refs/pull/4/head
31a45fc257e8433c8d8804e3e848cf61c9d3166c	refs/pull/4/merge</code></pre>
</div>
</div>
<div class="paragraph">
<p>البته، اگر در مخزن خودتان باشید و دستور <code>git ls-remote origin</code> یا هر ریموتی که می‌خواهید را اجرا کنید، چیزی مشابه این را مشاهده خواهید کرد.</p>
</div>
<div class="paragraph">
<p>اگر مخزن روی گیت‌هاب باشد و Pull Request هایی باز شده باشد، رفرنس‌هایی را خواهید دید که با refs/pull/ شروع می‌شوند.
این‌ها در واقع شاخه‌هایی هستند، اما چون زیر شاخه refs/heads/ نیستند، به‌طور معمول هنگام کلون یا fetch گرفتن دریافت نمی‌شوند — فرایند fetch معمولاً آن‌ها را نادیده می‌گیرد.</p>
</div>
<div class="paragraph">
<p>برای هر Pull Request دو رفرنس وجود دارد — رفرنس‌ای که با /head ختم می‌شود دقیقاً به همان کامیتی اشاره دارد که آخرین کامیت شاخه‌ی Pull Request است.
پس اگر کسی در مخزن ما یک Pull Request باز کند و شاخه‌شان bug-fix نام داشته باشد و به کامیت a5a775 اشاره کند، در مخزن ما شاخه‌ای به نام bug-fix وجود ندارد (چون آن شاخه در fork آن‌هاست)، اما یک رفرنس pull/&lt;شماره-pr&gt;/head خواهیم داشت که به a5a775 اشاره می‌کند.
این یعنی می‌توانیم خیلی راحت همه شاخه‌های Pull Request را یکجا دانلود کنیم بدون اینکه لازم باشد ریموت‌های زیادی اضافه کنیم.</p>
</div>
<div class="paragraph">
<p>حالا می‌توانید به‌صورت مستقیم این رفرنس‌ها را fetch کنید.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git fetch origin refs/pull/958/head
From https://github.com/libgit2/libgit2
 * branch            refs/pull/958/head -&gt; FETCH_HEAD</code></pre>
</div>
</div>
<div class="paragraph">
<p>این دستور به گیت می‌گوید: «به ریموت origin وصل شو و رفرنس به نام refs/pull/958/head را دانلود کن.»
گیت هم به راحتی این کار را انجام می‌دهد و همه چیز لازم برای ساختن آن رفرنس را دانلود می‌کند و اشاره‌گری به کامیت مورد نظر را در .git/FETCH_HEAD قرار می‌دهد.
بعد از آن می‌توانید با دستور git merge FETCH_HEAD آن تغییرات را در شاخه‌ای که می‌خواهید تست کنید، ادغام کنید، اما پیام کامیت ادغام ممکن است کمی عجیب به نظر برسد.
همچنین اگر تعداد زیادی Pull Request برای بررسی دارید، این کار می‌تواند خسته‌کننده شود.</p>
</div>
<div class="paragraph">
<p>یک راه دیگر هم وجود دارد تا همه Pull Requestها را یکجا fetch کنید و هر بار که به ریموت وصل می‌شوید، آن‌ها را به‌روز نگه دارید.
فایل .git/config را در ویرایشگر مورد علاقه‌تان باز کنید و به دنبال بخش مربوط به ریموت origin بگردید.
این بخش باید چیزی شبیه به این باشد:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ini" data-lang="ini">[remote "origin"]
    url = https://github.com/libgit2/libgit2
    fetch = +refs/heads/*:refs/remotes/origin/*</code></pre>
</div>
</div>
<div class="paragraph">
<p>خطی که با <code>fetch =</code> شروع می‌شود، یک «refspec» است.
این یک روش برای نگاشت نام‌ها در ریموت به نام‌های موجود در دایرکتوری محلی .git شماست.
این refspec خاص به گیت می‌گوید: «مواردی که در ریموت زیر refs/heads هستند باید در مخزن محلی من زیر refs/remotes/origin قرار بگیرند.»
شما می‌توانید این بخش را ویرایش کنید و یک refspec دیگر اضافه کنید:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ini" data-lang="ini">[remote "origin"]
    url = https://github.com/libgit2/libgit2.git
    fetch = +refs/heads/*:refs/remotes/origin/*
    fetch = +refs/pull/*/head:refs/remotes/origin/pr/*</code></pre>
</div>
</div>
<div class="paragraph">
<p>خط آخر به گیت می‌گوید: «تمام رفرنس‌هایی که شبیه refs/pull/123/head هستند، باید به صورت محلی زیر refs/remotes/origin/pr/123 ذخیره شوند.»
حالا اگر این فایل را ذخیره کنید و دستور <code>git fetch</code> را اجرا کنید:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git fetch
# …
 * [new ref]         refs/pull/1/head -&gt; origin/pr/1
 * [new ref]         refs/pull/2/head -&gt; origin/pr/2
 * [new ref]         refs/pull/4/head -&gt; origin/pr/4
# …</code></pre>
</div>
</div>
<div class="paragraph">
<p>حالا همه‌ی Pull Requestهای ریموت به صورت محلی با رفرنس‌هایی نمایش داده می‌شوند که مثل شاخه‌های دنبال‌کننده (tracking branches) عمل می‌کنند؛ این رفرنس‌ها فقط قابل‌خواندن هستند و هر بار که fetch می‌کنید به‌روزرسانی می‌شوند.
این کار تست کردن کدهای یک Pull Request به صورت محلی را بسیار آسان می‌کند:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout pr/2
Checking out files: 100% (3769/3769), done.
Branch pr/2 set up to track remote branch pr/2 from origin.
Switched to a new branch 'pr/2'</code></pre>
</div>
</div>
<div class="paragraph">
<p>دقیق‌بین‌ها متوجه «head» در انتهای قسمت ریموت رفرنس‌اسپک خواهند شد.
در گیت‌هاب همچنین رفرنس refs/pull/#/merge وجود دارد که نشان‌دهنده‌ی کامیتی است که در صورت زدن دکمه «merge» روی سایت، ایجاد خواهد شد.
این رفرنس به شما امکان می‌دهد قبل از کلیک روی دکمه، عملیات ادغام را تست کنید.</p>
</div>
</div>
<div class="sect4">
<h4 id="_pull_requests_on_pull_requests_pull_requests_روی_pull_requests">Pull Requests on Pull Requests (Pull Requests روی Pull Requests)</h4>
<div class="paragraph">
<p>شما فقط نمی‌توانید Pull Requestهایی باز کنید که به شاخه‌ی اصلی یا master اشاره دارند، بلکه می‌توانید Pull Request را به هر شاخه‌ای در شبکه هدف بگیرید.
در واقع، حتی می‌توانید یک Pull Request را هدف یک Pull Request دیگر قرار دهید.</p>
</div>
<div class="paragraph">
<p>اگر یک Pull Request را دیدید که در مسیر درستی حرکت می‌کند و ایده‌ای برای تغییر دارید که به آن وابسته است، یا مطمئن نیستید که آن تغییر ایده خوبی باشد، یا اینکه به شاخه‌ی هدف دسترسی push ندارید، می‌توانید مستقیماً یک Pull Request به آن باز کنید.</p>
</div>
<div class="paragraph">
<p>وقتی می‌خواهید یک Pull Request باز کنید، بالای صفحه جعبه‌ای وجود دارد که مشخص می‌کند کدام شاخه را می‌خواهید تغییرات را روی آن اعمال کنید (pull to) و از کدام شاخه می‌خواهید تغییرات را بگیرید (pull from).
اگر روی دکمه «Edit» در سمت راست آن جعبه کلیک کنید، می‌توانید نه تنها شاخه‌ها را تغییر دهید بلکه فورک (fork) مورد نظر را هم عوض کنید.</p>
</div>
<div id="_pr_targets" class="imageblock">
<div class="content">
<img src="{{< relurl "book/fa/v2/images/maint-04-target.png" >}}" alt="PR targets">
</div>
<div class="title">نمودار 115. Manually change the Pull Request target fork and branch.</div>
</div>
<div class="paragraph">
<p>اینجا به‌راحتی می‌توانید مشخص کنید که شاخه‌ی جدیدتان را به یک Pull Request دیگر یا به یک فورک (fork) دیگر از پروژه ادغام کنید.</p>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_mentions_and_notifications_منشنها_و_اعلانها">Mentions and Notifications (منشن‌ها و اعلان‌ها)</h3>
<div class="paragraph">
<p>گیت‌هاب یک سیستم اعلان خیلی خوب دارد که وقتی سوالی دارید یا به بازخورد از افراد یا تیم‌های خاص نیاز دارید، بسیار کاربردی است.</p>
</div>
<div class="paragraph">
<p>در هر کامنتی می‌توانید با نوشتن کاراکتر @ شروع کنید و گیت‌هاب به‌صورت خودکار نام و نام‌کاربری کسانی را که همکار یا مشارکت‌کننده در پروژه هستند، به شما پیشنهاد می‌دهد.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/fa/v2/images/maint-05-mentions.png" >}}" alt="Mentions">
</div>
<div class="title">نمودار 116. Start typing @ to mention someone.</div>
</div>
<div class="paragraph">
<p>می‌توانید کاربری را هم منشن کنید که در آن لیست کشویی نیست، اما معمولاً قابلیت تکمیل خودکار این کار را سریع‌تر می‌کند.</p>
</div>
<div class="paragraph">
<p>وقتی کامنتی با منشن یک کاربر ارسال کنید، آن کاربر مطلع خواهد شد.
این یعنی منشن کردن یک روش بسیار موثر برای جلب توجه افراد به مکالمات است، به جای اینکه آن‌ها مجبور باشند مدام چک کنند.
در Pull Requestهای گیت‌هاب، معمولاً افراد دیگر اعضای تیم یا شرکت خود را برای بررسی یک Issue یا Pull Request به گفتگو دعوت می‌کنند.</p>
</div>
<div class="paragraph">
<p>اگر کسی در یک Pull Request یا Issue منشن شود، به آن موضوع «اشتراک» (subscribe) داده می‌شود و هر بار که فعالیتی روی آن انجام شود، اعلان دریافت خواهد کرد.
شما هم اگر خودتان آن را باز کرده باشید، یا در حال دنبال کردن (watch) مخزن باشید، یا روی چیزی نظر گذاشته باشید، به‌طور خودکار عضو آن موضوع خواهید شد.
اگر دیگر نمی‌خواهید اعلان دریافت کنید، یک دکمه «Unsubscribe» روی صفحه وجود دارد که با کلیک روی آن می‌توانید دریافت اعلان‌ها را متوقف کنید.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/fa/v2/images/maint-06-unsubscribe.png" >}}" alt="Unsubscribe">
</div>
<div class="title">نمودار 117. Unsubscribe from an Issue or Pull Request.</div>
</div>
<div class="sect4">
<h4 id="_the_notifications_page_صفحه_اعلانها">The Notifications Page (صفحه اعلان‌ها)</h4>
<div class="paragraph">
<p>وقتی اینجا درباره «اعلان‌ها» در گیت‌هاب صحبت می‌کنیم، منظورمان روشی خاص است که گیت‌هاب برای اطلاع‌رسانی به شما هنگام وقوع رویدادها استفاده می‌کند و چند روش مختلف برای تنظیم آن وجود دارد.
اگر به تب «Notification center» در صفحه تنظیمات بروید، می‌توانید برخی از گزینه‌های موجود را مشاهده کنید.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/fa/v2/images/maint-07-notifications.png" >}}" alt="Notification center">
</div>
<div class="title">نمودار 118. Notification center options.</div>
</div>
<div class="paragraph">
<p>دو گزینه برای دریافت اعلان‌ها وجود دارد: «ایمیل» و «وب»؛
شما می‌توانید برای زمانی که خودتان در فعالیت‌ها مشارکت دارید و برای فعالیت‌های مخازنی که دنبال می‌کنید، هر کدام را به دلخواه انتخاب کنید، هیچ‌کدام را انتخاب نکنید، یا هر دو را فعال کنید.</p>
</div>
<div class="sect5">
<h6 id="_web_notifications_اعلانهای_وب">Web Notifications (اعلان‌های وب)</h6>
<div class="paragraph">
<p>اعلان‌های وب فقط روی خود گیت‌هاب وجود دارند و فقط از طریق گیت‌هاب قابل مشاهده‌اند.
اگر این گزینه را در تنظیمات خود فعال کرده باشید و برایتان اعلان جدیدی بیاید، یک نقطه آبی کوچک روی آیکون اعلان‌ها در بالای صفحه‌تان ظاهر می‌شود، همانطور که در <a href="{{< relurl "book/fa/v2/ch00/_not_center" >}}">Notification center.</a> می‌بینید.</p>
</div>
<div id="_not_center" class="imageblock">
<div class="content">
<img src="{{< relurl "book/fa/v2/images/maint-08-notifications-page.png" >}}" alt="Notification center">
</div>
<div class="title">نمودار 119. Notification center.</div>
</div>
<div class="paragraph">
<p>اگر روی آن کلیک کنید، فهرستی از تمام اعلان‌هایی که دریافت کرده‌اید را خواهید دید که بر اساس پروژه‌ها گروه‌بندی شده‌اند.
می‌توانید با کلیک روی نام یک پروژه در نوار کناری سمت چپ، فقط اعلان‌های همان پروژه را فیلتر کنید.
همچنین می‌توانید با کلیک روی آیکون تیک کنار هر اعلان، آن اعلان را تأیید (acknowledge) کنید، یا با کلیک روی تیک بالای گروه، همه اعلان‌های آن پروژه را تأیید نمایید.
در کنار هر تیک، دکمه‌ای به شکل «بی‌صدا» (mute) وجود دارد که با کلیک روی آن، دیگر اعلان‌های آن مورد برای شما ارسال نخواهد شد.</p>
</div>
<div class="paragraph">
<p>تمام این ابزارها برای مدیریت تعداد زیادی اعلان بسیار کاربردی هستند.
بسیاری از کاربران حرفه‌ای گیت‌هاب، اعلان‌های ایمیلی را به طور کامل غیرفعال می‌کنند و همه اعلان‌های خود را فقط از طریق همین صفحه مدیریت می‌کنند.</p>
</div>
</div>
<div class="sect5">
<h6 id="_email_notifications_اعلانهای_ایمیلی">Email Notifications (اعلان‌های ایمیلی)</h6>
<div class="paragraph">
<p>اعلان‌های ایمیلی، روش دیگری برای مدیریت اعلان‌ها در گیت‌هاب است.
اگر این گزینه را فعال کرده باشید، برای هر اعلان یک ایمیل دریافت خواهید کرد.
نمونه‌هایی از این ایمیل‌ها را در <a href="{{< relurl "book/fa/v2/ch00/_email_notification" >}}">Comments sent as email notifications</a> و <a href="{{< relurl "book/fa/v2/ch00/_email_pr" >}}">[_email_pr]</a> دیدیم.
این ایمیل‌ها به صورت موضوع‌بندی شده (threaded) ارسال می‌شوند که اگر از ایمیل کلاینتی با قابلیت موضوع‌بندی استفاده کنید، کار را بسیار راحت می‌کند.</p>
</div>
<div class="paragraph">
<p>همچنین در هدر ایمیل‌هایی که گیت‌هاب برای شما ارسال می‌کند، مقدار زیادی داده متا (metadata) قرار دارد که می‌تواند برای ساخت فیلترها و قواعد سفارشی بسیار مفید باشد.</p>
</div>
<div class="paragraph">
<p>مثلاً اگر به هدر ایمیلی که به تونی در نمونه‌ی <a href="{{< relurl "book/fa/v2/ch00/_email_pr" >}}">[_email_pr]</a> ارسال شده نگاه کنیم، اطلاعات زیر را خواهیم دید:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-mbox" data-lang="mbox">To: tonychacon/fade &lt;fade@noreply.github.com&gt;
Message-ID: &lt;tonychacon/fade/pull/1@github.com&gt;
Subject: [fade] Wait longer to see the dimming effect better (#1)
X-GitHub-Recipient: tonychacon
List-ID: tonychacon/fade &lt;fade.tonychacon.github.com&gt;
List-Archive: https://github.com/tonychacon/fade
List-Post: &lt;mailto:reply+i-4XXX@reply.github.com&gt;
List-Unsubscribe: &lt;mailto:unsub+i-XXX@reply.github.com&gt;,...
X-GitHub-Recipient-Address: tchacon@example.com</code></pre>
</div>
</div>
<div class="paragraph">
<p>چند نکته جالب درباره این موارد وجود دارد:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>اگر بخواهید ایمیل‌ها را برای این پروژه خاص یا حتی یک Pull Request مشخص برجسته کنید یا به پوشه یا آدرس دیگری هدایت کنید، اطلاعات موجود در فیلد Message-ID تمام داده‌های لازم را به صورت قالب &lt;user&gt;/&lt;project&gt;/&lt;type&gt;/&lt;id&gt; در اختیار شما می‌گذارد.
به عنوان مثال اگر موضوع ایمیل مربوط به یک Issue بود، به جای pull در قسمت &lt;type&gt; عبارت issues می‌آمد.</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>فیلدهای List-Post و List-Unsubscribe به این معنی هستند که اگر کلاینت ایمیل شما این فیلدها را پشتیبانی کند، می‌توانید به راحتی پاسخ ارسال کنید یا از دریافت اعلان‌های بیشتر (Unsubscribe) برای آن رشته (thread) منصرف شوید.
این عملکرد معادل کلیک کردن روی دکمه «mute» در نسخه وب اعلان یا دکمه «Unsubscribe» در صفحه Issue یا Pull Request است.</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>همچنین خوب است بدانید اگر هر دو نوع اعلان ایمیلی و وبی فعال باشند، وقتی ایمیل را در کلاینت خود خواندید (و اگر اجازه‌ی بارگذاری تصاویر در ایمیل داده باشید)، نسخه وبی اعلان هم به صورت خوانده شده علامت‌گذاری می‌شود.</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_special_files_فایل_های_ویژه">Special Files (فایل های ویژه)</h3>
<div class="paragraph">
<p>گیت‌هاب چند فایل خاص دارد که اگر در مخزن شما وجود داشته باشند، به طور خودکار آن‌ها را شناسایی و رفتار مخصوصی با آن‌ها انجام می‌دهد.
اگر مایلید، می‌توانم درباره این فایل‌های خاص و کاربردشان بیشتر توضیح بدهم.</p>
</div>
</div>
<div class="sect3">
<h3 id="_readme_ریدمی">README (ریدمی)</h3>
<div class="paragraph">
<p>فایل اول، فایل <code>README</code> است که می‌تواند تقریباً در هر فرمتی باشد که گیت‌هاب به عنوان متن قابل نمایش شناسایی می‌کند.
مثلاً: README، README.md، README.asciidoc و غیره.</p>
</div>
<div class="paragraph">
<p>وقتی گیت‌هاب چنین فایلی را در مخزن شما ببیند، آن را در صفحه‌ی اصلی (landing page) پروژه به صورت زیبا و خوانا نمایش می‌دهد.</p>
</div>
<div class="paragraph">
<p>معمولاً تیم‌ها از این فایل برای جمع‌آوری اطلاعات مهم و اصلی پروژه استفاده می‌کنند، مخصوصاً برای افرادی که تازه با پروژه آشنا می‌شوند. این اطلاعات معمولاً شامل موارد زیر است:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>هدف و کاربرد پروژه چیست؟</p>
</li>
<li>
<p>چطور پروژه را نصب و پیکربندی کنیم؟</p>
</li>
<li>
<p>نمونه‌ای از استفاده یا نحوه اجرای پروژه</p>
</li>
<li>
<p>مجوز (License) پروژه تحت چه شرایطی است</p>
</li>
<li>
<p>چطور می‌توان در پروژه مشارکت کرد (contributing)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>از آنجا که گیت‌هاب این فایل را رندر می‌کند، شما می‌توانید تصاویر، لینک‌ها و قالب‌بندی Markdown یا هر فرمت پشتیبانی شده را در آن قرار دهید تا فهم و استفاده از پروژه برای دیگران آسان‌تر شود.</p>
</div>
</div>
<div class="sect3">
<h3 id="_contributing_مشارکت">CONTRIBUTING (مشارکت)</h3>
<div class="paragraph">
<p>فایل ویژه‌ی دیگری که گیت‌هاب آن را شناسایی می‌کند، فایل CONTRIBUTING است.
اگر فایلی با نام CONTRIBUTING و با هر پسوندی داشته باشید، گیت‌هاب هنگام باز کردن یک Pull Request توسط هر کسی، <a href="{{< relurl "book/fa/v2/ch00/_contrib_file" >}}">Opening a Pull Request when a CONTRIBUTING file exists.</a> را نمایش خواهد داد.</p>
</div>
<div id="_contrib_file" class="imageblock">
<div class="content">
<img src="{{< relurl "book/fa/v2/images/maint-09-contrib.png" >}}" alt="Contributing notice">
</div>
<div class="title">نمودار 120. Opening a Pull Request when a CONTRIBUTING file exists.</div>
</div>
<div class="paragraph">
<p>ایده اینجا این است که می‌توانید موارد مشخصی را که می‌خواهید یا نمی‌خواهید در یک Pull Request به پروژه‌تان ارسال شود، تعیین کنید.
به این صورت، افراد ممکن است واقعاً دستورالعمل‌ها را قبل از باز کردن Pull Request بخوانند.</p>
</div>
</div>
<div class="sect3">
<h3 id="_project_administration_مدیریت_پروژه">Project Administration (مدیریت پروژه)</h3>
<div class="paragraph">
<p>به‌طور کلی، کارهای مدیریتی زیادی وجود ندارد که بتوانید روی یک پروژهٔ تکی انجام دهید، اما چند مورد هستند که ممکن است برایتان جالب باشند.</p>
</div>
<div class="sect4">
<h4 id="_changing_the_default_branch_تغییر_شاخهٔ_پیشفرض">Changing the Default Branch (تغییر شاخهٔ پیش‌فرض)</h4>
<div class="paragraph">
<p>اگر به‌جای شاخهٔ «master» از شاخهٔ دیگری به‌عنوان شاخهٔ پیش‌فرض استفاده می‌کنید—شاخه‌ای که می‌خواهید افراد Pull Request های خود را به آن بفرستند یا به‌صورت پیش‌فرض آن را ببینند—می‌توانید این تنظیم را در صفحهٔ تنظیمات مخزن خود، در بخش «Options»، تغییر دهید.</p>
</div>
<div id="_default_branch" class="imageblock">
<div class="content">
<img src="{{< relurl "book/fa/v2/images/maint-10-default-branch.png" >}}" alt="Default branch">
</div>
<div class="title">نمودار 121. Change the default branch for a project.</div>
</div>
<div class="paragraph">
<p>کافی‌ست شاخهٔ پیش‌فرض را از منوی کشویی تغییر دهید؛ از آن پس، این شاخه به‌عنوان شاخهٔ پیش‌فرض برای تمام عملیات‌های اصلی در نظر گرفته خواهد شد—از جمله شاخه‌ای که هنگام کلون کردن مخزن، به‌صورت پیش‌فرض انتخاب و بررسی (checkout) می‌شود.</p>
</div>
</div>
<div class="sect4">
<h4 id="_transferring_a_project_انتقال_پروژه">Transferring a Project (انتقال پروژه)</h4>
<div class="paragraph">
<p>اگر می‌خواهید پروژه‌ای را به کاربر یا سازمان دیگری در گیت‌هاب منتقل کنید، گزینه‌ای به نام «Transfer ownership» (انتقال مالکیت) در پایین همان تب «Options» در صفحه تنظیمات مخزن شما وجود دارد که این امکان را فراهم می‌کند.</p>
</div>
<div id="_transfer_project" class="imageblock">
<div class="content">
<img src="{{< relurl "book/fa/v2/images/maint-11-transfer.png" >}}" alt="Transfer">
</div>
<div class="title">نمودار 122. Transfer a project to another GitHub user or Organization.</div>
</div>
<div class="paragraph">
<p>این گزینه زمانی مفید است که می‌خواهید پروژه‌ای را رها کنید و فرد دیگری قصد دارد آن را ادامه دهد، یا زمانی که پروژه‌تان بزرگ‌تر شده و می‌خواهید آن را به یک سازمان منتقل کنید.</p>
</div>
<div class="paragraph">
<p>این کار نه‌تنها مخزن را همراه با تمام دنبال‌کنندگان (watchers) و ستاره‌ها (stars) به مکان جدید منتقل می‌کند، بلکه یک ریدایرکت (تغییر مسیر) از آدرس قبلی شما به محل جدید تنظیم می‌نماید.
این ریدایرکت فقط محدود به درخواست‌های وب نیست، بلکه شامل clone و fetch در گیت نیز می‌شود.</p>
</div>
</div>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>