---
### DO NOT EDIT! Generated by script/update-docs.rb

category: manual
section: documentation
subsection: manual
title: Git - reftable Documentation
docname: reftable
version: 2.32.0
aliases:
- "/docs/reftable/2.32.0/index.html"
- "/docs/reftable/2.32.1/index.html"
- "/docs/reftable/2.32.2/index.html"
- "/docs/reftable/2.32.3/index.html"
- "/docs/reftable/2.32.4/index.html"
- "/docs/reftable/2.32.5/index.html"
- "/docs/reftable/2.32.6/index.html"
- "/docs/reftable/2.32.7/index.html"
- "/docs/reftable/2.33.0/index.html"
- "/docs/reftable/2.33.1/index.html"
- "/docs/reftable/2.33.2/index.html"
- "/docs/reftable/2.33.3/index.html"
- "/docs/reftable/2.33.4/index.html"
- "/docs/reftable/2.33.5/index.html"
- "/docs/reftable/2.33.6/index.html"
- "/docs/reftable/2.33.7/index.html"
- "/docs/reftable/2.33.8/index.html"
- "/docs/reftable/2.34.0/index.html"
- "/docs/reftable/2.34.1/index.html"
- "/docs/reftable/2.34.2/index.html"
- "/docs/reftable/2.34.3/index.html"
- "/docs/reftable/2.34.4/index.html"
- "/docs/reftable/2.34.5/index.html"
- "/docs/reftable/2.34.6/index.html"
- "/docs/reftable/2.34.7/index.html"
- "/docs/reftable/2.34.8/index.html"
- "/docs/reftable/2.35.0/index.html"
- "/docs/reftable/2.35.1/index.html"
- "/docs/reftable/2.35.2/index.html"
- "/docs/reftable/2.35.3/index.html"
- "/docs/reftable/2.35.4/index.html"
- "/docs/reftable/2.35.5/index.html"
- "/docs/reftable/2.35.6/index.html"
- "/docs/reftable/2.35.7/index.html"
- "/docs/reftable/2.35.8/index.html"
---
<div class="sect1">
<h2 id="_reftable"><a class="anchor" href="#_reftable"></a>reftable</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_overview"><a class="anchor" href="#_overview"></a>Overview</h3>
<div class="sect3">
<h4 id="_problem_statement"><a class="anchor" href="#_problem_statement"></a>Problem statement</h4>
<div class="paragraph">
<p>Some repositories contain a lot of references (e.g. android at 866k,
rails at 31k). The existing packed-refs format takes up a lot of space
(e.g. 62M), and does not scale with additional references. Lookup of a
single reference requires linearly scanning the file.</p>
</div>
<div class="paragraph">
<p>Atomic pushes modifying multiple references require copying the entire
packed-refs file, which can be a considerable amount of data moved
(e.g. 62M in, 62M out) for even small transactions (2 refs modified).</p>
</div>
<div class="paragraph">
<p>Repositories with many loose references occupy a large number of disk
blocks from the local file system, as each reference is its own file
storing 41 bytes (and another file for the corresponding reflog). This
negatively affects the number of inodes available when a large number of
repositories are stored on the same filesystem. Readers can be penalized
due to the larger number of syscalls required to traverse and read the
<span class='synopsis'><code>$GIT_DIR/refs</code></span> directory.</p>
</div>
</div>
<div class="sect3">
<h4 id="_objectives"><a class="anchor" href="#_objectives"></a>Objectives</h4>
<div class="ulist">
<ul>
<li>
<p>Near constant time lookup for any single reference, even when the
repository is cold and not in process or kernel cache.</p>
</li>
<li>
<p>Near constant time verification if an object name is referred to by at least
one reference (for allow-tip-sha1-in-want).</p>
</li>
<li>
<p>Efficient enumeration of an entire namespace, such as <span class='synopsis'><code>refs/tags/</code></span>.</p>
</li>
<li>
<p>Support atomic push with <span class='synopsis'><code>O</code>(<code>size_of_update</code>)</span> operations.</p>
</li>
<li>
<p>Combine reflog storage with ref storage for small transactions.</p>
</li>
<li>
<p>Separate reflog storage for base refs and historical logs.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_description"><a class="anchor" href="#_description"></a>Description</h4>
<div class="paragraph">
<p>A reftable file is a portable binary file format customized for
reference storage. References are sorted, enabling linear scans, binary
search lookup, and range scans.</p>
</div>
<div class="paragraph">
<p>Storage in the file is organized into variable sized blocks. Prefix
compression is used within a single block to reduce disk space. Block
size and alignment is tunable by the writer.</p>
</div>
</div>
<div class="sect3">
<h4 id="_performance"><a class="anchor" href="#_performance"></a>Performance</h4>
<div class="paragraph">
<p>Space used, packed-refs vs. reftable:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">repository</th>
<th class="tableblock halign-right valign-top">packed-refs</th>
<th class="tableblock halign-right valign-top">reftable</th>
<th class="tableblock halign-right valign-top">% original</th>
<th class="tableblock halign-right valign-top">avg ref</th>
<th class="tableblock halign-right valign-top">avg obj</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">android</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">62.2 M</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">36.1 M</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">58.0%</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">33 bytes</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">5 bytes</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">rails</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">1.8 M</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">1.1 M</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">57.7%</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">29 bytes</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">4 bytes</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">git</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">78.7 K</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">48.1 K</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">61.0%</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">50 bytes</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">4 bytes</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">git (heads)</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">332 b</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">269 b</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">81.0%</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">33 bytes</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">0 bytes</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Scan (read 866k refs), by reference name lookup (single ref from 866k
refs), and by SHA-1 lookup (refs with that SHA-1, from 866k refs):</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">format</th>
<th class="tableblock halign-right valign-top">cache</th>
<th class="tableblock halign-right valign-top">scan</th>
<th class="tableblock halign-right valign-top">by name</th>
<th class="tableblock halign-right valign-top">by SHA-1</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">packed-refs</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">cold</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">402 ms</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">409,660.1 usec</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">412,535.8 usec</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">packed-refs</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">hot</p></td>
<td class="tableblock halign-right valign-top"></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">6,844.6 usec</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">20,110.1 usec</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">reftable</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">cold</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">112 ms</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">33.9 usec</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">323.2 usec</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">reftable</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">hot</p></td>
<td class="tableblock halign-right valign-top"></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">20.2 usec</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">320.8 usec</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Space used for 149,932 log entries for 43,061 refs, reflog vs. reftable:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">format</th>
<th class="tableblock halign-right valign-top">size</th>
<th class="tableblock halign-right valign-top">avg entry</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">$GIT_DIR/logs</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">173 M</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">1209 bytes</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">reftable</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">5 M</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">37 bytes</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_details"><a class="anchor" href="#_details"></a>Details</h3>
<div class="sect3">
<h4 id="_peeling"><a class="anchor" href="#_peeling"></a>Peeling</h4>
<div class="paragraph">
<p>References stored in a reftable are peeled, a record for an annotated
(or signed) tag records both the tag object, and the object it refers
to. This is analogous to storage in the packed-refs format.</p>
</div>
</div>
<div class="sect3">
<h4 id="_reference_name_encoding"><a class="anchor" href="#_reference_name_encoding"></a>Reference name encoding</h4>
<div class="paragraph">
<p>Reference names are an uninterpreted sequence of bytes that must pass
<a href='{{< relurl "docs/git-check-ref-format" >}}'>git-check-ref-format[1]</a> as a valid reference name.</p>
</div>
</div>
<div class="sect3">
<h4 id="_key_unicity"><a class="anchor" href="#_key_unicity"></a>Key unicity</h4>
<div class="paragraph">
<p>Each entry must have a unique key; repeated keys are disallowed.</p>
</div>
</div>
<div class="sect3">
<h4 id="_network_byte_order"><a class="anchor" href="#_network_byte_order"></a>Network byte order</h4>
<div class="paragraph">
<p>All multi-byte, fixed width fields are in network byte order.</p>
</div>
</div>
<div class="sect3">
<h4 id="_varint_encoding"><a class="anchor" href="#_varint_encoding"></a>Varint encoding</h4>
<div class="paragraph">
<p>Varint encoding is identical to the ofs-delta encoding method used
within pack files.</p>
</div>
<div class="paragraph">
<p>Decoder works such as:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>val = buf[ptr] &amp; 0x7f
while (buf[ptr] &amp; 0x80) {
  ptr++
  val = ((val + 1) &lt;&lt; 7) | (buf[ptr] &amp; 0x7f)
}</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ordering"><a class="anchor" href="#_ordering"></a>Ordering</h4>
<div class="paragraph">
<p>Blocks are lexicographically ordered by their first reference.</p>
</div>
</div>
<div class="sect3">
<h4 id="_directoryfile_conflicts"><a class="anchor" href="#_directoryfile_conflicts"></a>Directory/file conflicts</h4>
<div class="paragraph">
<p>The reftable format accepts both <span class='synopsis'><code>refs/heads/foo</code></span> and
<span class='synopsis'><code>refs/heads/foo/bar</code></span> as distinct references.</p>
</div>
<div class="paragraph">
<p>This property is useful for retaining log records in reftable, but may
confuse versions of Git using <span class='synopsis'><code>$GIT_DIR/refs</code></span> directory tree to maintain
references. Users of reftable may choose to continue to reject <span class='synopsis'><code>foo</code></span> and
<span class='synopsis'><code>foo/bar</code></span> type conflicts to prevent problems for peers.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_file_format"><a class="anchor" href="#_file_format"></a>File format</h3>
<div class="sect3">
<h4 id="_structure"><a class="anchor" href="#_structure"></a>Structure</h4>
<div class="paragraph">
<p>A reftable file has the following high-level structure:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>first_block {
  header
  first_ref_block
}
ref_block*
ref_index*
obj_block*
obj_index*
log_block*
log_index*
footer</pre>
</div>
</div>
<div class="paragraph">
<p>A log-only file omits the <span class='synopsis'><code>ref_block</code></span>, <span class='synopsis'><code>ref_index</code></span>, <span class='synopsis'><code>obj_block</code></span> and
<span class='synopsis'><code>obj_index</code></span> sections, containing only the file header and log block:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>first_block {
  header
}
log_block*
log_index*
footer</pre>
</div>
</div>
<div class="paragraph">
<p>in a log-only file the first log block immediately follows the file
header, without padding to block alignment.</p>
</div>
</div>
<div class="sect3">
<h4 id="_block_size"><a class="anchor" href="#_block_size"></a>Block size</h4>
<div class="paragraph">
<p>The file&#8217;s block size is arbitrarily determined by the writer, and does
not have to be a power of 2. The block size must be larger than the
longest reference name or log entry used in the repository, as
references cannot span blocks.</p>
</div>
<div class="paragraph">
<p>Powers of two that are friendly to the virtual memory system or
filesystem (such as 4k or 8k) are recommended. Larger sizes (64k) can
yield better compression, with a possible increased cost incurred by
readers during access.</p>
</div>
<div class="paragraph">
<p>The largest block size is <span class='synopsis'><code>16777215</code></span> bytes (15.99 MiB).</p>
</div>
</div>
<div class="sect3">
<h4 id="_block_alignment"><a class="anchor" href="#_block_alignment"></a>Block alignment</h4>
<div class="paragraph">
<p>Writers may choose to align blocks at multiples of the block size by
including <span class='synopsis'><code>padding</code></span> filled with NUL bytes at the end of a block to round
out to the chosen alignment. When alignment is used, writers must
specify the alignment with the file header&#8217;s <span class='synopsis'><code>block_size</code></span> field.</p>
</div>
<div class="paragraph">
<p>Block alignment is not required by the file format. Unaligned files must
set <span class='synopsis'><code>block_size</code> <code>=</code> <code>0</code></span> in the file header, and omit <span class='synopsis'><code>padding</code></span>. Unaligned
files with more than one ref block must include the <a href="#Ref-index">ref
index</a> to support fast lookup. Readers must be able to read both aligned
and non-aligned files.</p>
</div>
<div class="paragraph">
<p>Very small files (e.g. a single ref block) may omit <span class='synopsis'><code>padding</code></span> and the ref
index to reduce total file size.</p>
</div>
</div>
<div class="sect3">
<h4 id="_header_version_1"><a class="anchor" href="#_header_version_1"></a>Header (version 1)</h4>
<div class="paragraph">
<p>A 24-byte header appears at the beginning of the file:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>'REFT'
uint8( version_number = 1 )
uint24( block_size )
uint64( min_update_index )
uint64( max_update_index )</pre>
</div>
</div>
<div class="paragraph">
<p>Aligned files must specify <span class='synopsis'><code>block_size</code></span> to configure readers with the
expected block alignment. Unaligned files must set <span class='synopsis'><code>block_size</code> <code>=</code> <code>0</code></span>.</p>
</div>
<div class="paragraph">
<p>The <span class='synopsis'><code>min_update_index</code></span> and <span class='synopsis'><code>max_update_index</code></span> describe bounds for the
<span class='synopsis'><code>update_index</code></span> field of all log records in this file. When reftables are
used in a stack for <a href="#Update-transactions">transactions</a>, these
fields can order the files such that the prior file&#8217;s
<span class='synopsis'><code>max_update_index</code> <code>+</code> <code>1</code></span> is the next file&#8217;s <span class='synopsis'><code>min_update_index</code></span>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_header_version_2"><a class="anchor" href="#_header_version_2"></a>Header (version 2)</h4>
<div class="paragraph">
<p>A 28-byte header appears at the beginning of the file:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>'REFT'
uint8( version_number = 2 )
uint24( block_size )
uint64( min_update_index )
uint64( max_update_index )
uint32( hash_id )</pre>
</div>
</div>
<div class="paragraph">
<p>The header is identical to <span class='synopsis'><code>version_number=1</code></span>, with the 4-byte hash ID
("sha1" for SHA1 and "s256" for SHA-256) append to the header.</p>
</div>
<div class="paragraph">
<p>For maximum backward compatibility, it is recommended to use version 1 when
writing SHA1 reftables.</p>
</div>
</div>
<div class="sect3">
<h4 id="_first_ref_block"><a class="anchor" href="#_first_ref_block"></a>First ref block</h4>
<div class="paragraph">
<p>The first ref block shares the same block as the file header, and is 24
bytes smaller than all other blocks in the file. The first block
immediately begins after the file header, at position 24.</p>
</div>
<div class="paragraph">
<p>If the first block is a log block (a log-only file), its block header
begins immediately at position 24.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ref_block_format"><a class="anchor" href="#_ref_block_format"></a>Ref block format</h4>
<div class="paragraph">
<p>A ref block is written as:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>'r'
uint24( block_len )
ref_record+
uint24( restart_offset )+
uint16( restart_count )

padding?</pre>
</div>
</div>
<div class="paragraph">
<p>Blocks begin with <span class='synopsis'><code>block_type</code> <code>=</code> <code>r'</code></span> and a 3-byte <span class='synopsis'><code>block_len</code></span> which
encodes the number of bytes in the block up to, but not including the
optional <span class='synopsis'><code>padding</code></span>. This is always less than or equal to the file&#8217;s
block size. In the first ref block, <span class='synopsis'><code>block_len</code></span> includes 24 bytes for
the file header.</p>
</div>
<div class="paragraph">
<p>The 2-byte <span class='synopsis'><code>restart_count</code></span> stores the number of entries in the
<span class='synopsis'><code>restart_offset</code></span> list, which must not be empty. Readers can use
<span class='synopsis'><code>restart_count</code></span> to binary search between restarts before starting a
linear scan.</p>
</div>
<div class="paragraph">
<p>Exactly <span class='synopsis'><code>restart_count</code></span> 3-byte <span class='synopsis'><code>restart_offset</code></span> values precedes the
<span class='synopsis'><code>restart_count</code></span>. Offsets are relative to the start of the block and
refer to the first byte of any <span class='synopsis'><code>ref_record</code></span> whose name has not been
prefix compressed. Entries in the <span class='synopsis'><code>restart_offset</code></span> list must be sorted,
ascending. Readers can start linear scans from any of these records.</p>
</div>
<div class="paragraph">
<p>A variable number of <span class='synopsis'><code>ref_record</code></span> fill the middle of the block,
describing reference names and values. The format is described below.</p>
</div>
<div class="paragraph">
<p>As the first ref block shares the first file block with the file header,
all <span class='synopsis'><code>restart_offset</code></span> in the first block are relative to the start of the
file (position 0), and include the file header. This forces the first
<span class='synopsis'><code>restart_offset</code></span> to be <span class='synopsis'><code>28</code></span>.</p>
</div>
<div class="sect4">
<h5 id="_ref_record"><a class="anchor" href="#_ref_record"></a>ref record</h5>
<div class="paragraph">
<p>A <span class='synopsis'><code>ref_record</code></span> describes a single reference, storing both the name and
its value(s). Records are formatted as:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>varint( prefix_length )
varint( (suffix_length &lt;&lt; 3) | value_type )
suffix
varint( update_index_delta )
value?</pre>
</div>
</div>
<div class="paragraph">
<p>The <span class='synopsis'><code>prefix_length</code></span> field specifies how many leading bytes of the prior
reference record&#8217;s name should be copied to obtain this reference&#8217;s
name. This must be 0 for the first reference in any block, and also must
be 0 for any <span class='synopsis'><code>ref_record</code></span> whose offset is listed in the <span class='synopsis'><code>restart_offset</code></span>
table at the end of the block.</p>
</div>
<div class="paragraph">
<p>Recovering a reference name from any <span class='synopsis'><code>ref_record</code></span> is a simple concat:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>this_name = prior_name[0..prefix_length] + suffix</pre>
</div>
</div>
<div class="paragraph">
<p>The <span class='synopsis'><code>suffix_length</code></span> value provides the number of bytes available in
<span class='synopsis'><code>suffix</code></span> to copy from <span class='synopsis'><code>suffix</code></span> to complete the reference name.</p>
</div>
<div class="paragraph">
<p>The <span class='synopsis'><code>update_index</code></span> that last modified the reference can be obtained by
adding <span class='synopsis'><code>update_index_delta</code></span> to the <span class='synopsis'><code>min_update_index</code></span> from the file
header: <span class='synopsis'><code>min_update_index</code> <code>+</code> <code>update_index_delta</code></span>.</p>
</div>
<div class="paragraph">
<p>The <span class='synopsis'><code>value</code></span> follows. Its format is determined by <span class='synopsis'><code>value_type</code></span>, one of
the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><span class='synopsis'><code>0x0</code></span>: deletion; no value data (see transactions, below)</p>
</li>
<li>
<p><span class='synopsis'><code>0x1</code></span>: one object name; value of the ref</p>
</li>
<li>
<p><span class='synopsis'><code>0x2</code></span>: two object names; value of the ref, peeled target</p>
</li>
<li>
<p><span class='synopsis'><code>0x3</code></span>: symbolic reference: <span class='synopsis'><code>varint</code>( <code>target_len</code> ) <code>target</code></span></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Symbolic references use <span class='synopsis'><code>0x3</code></span>, followed by the complete name of the
reference target. No compression is applied to the target name.</p>
</div>
<div class="paragraph">
<p>Types <span class='synopsis'><code>0x4..0x7</code></span> are reserved for future use.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ref_index"><a class="anchor" href="#_ref_index"></a>Ref index</h4>
<div class="paragraph">
<p>The ref index stores the name of the last reference from every ref block
in the file, enabling reduced disk seeks for lookups. Any reference can
be found by searching the index, identifying the containing block, and
searching within that block.</p>
</div>
<div class="paragraph">
<p>The index may be organized into a multi-level index, where the 1st level
index block points to additional ref index blocks (2nd level), which may
in turn point to either additional index blocks (e.g. 3rd level) or ref
blocks (leaf level). Disk reads required to access a ref go up with
higher index levels. Multi-level indexes may be required to ensure no
single index block exceeds the file format&#8217;s max block size of
<span class='synopsis'><code>16777215</code></span> bytes (15.99 MiB). To achieve constant O(1) disk seeks for
lookups the index must be a single level, which is permitted to exceed
the file&#8217;s configured block size, but not the format&#8217;s max block size of
15.99 MiB.</p>
</div>
<div class="paragraph">
<p>If present, the ref index block(s) appears after the last ref block.</p>
</div>
<div class="paragraph">
<p>If there are at least 4 ref blocks, a ref index block should be written
to improve lookup times. Cold reads using the index require 2 disk reads
(read index, read block), and binary searching &lt; 4 blocks also requires
&#8656; 2 reads. Omitting the index block from smaller files saves space.</p>
</div>
<div class="paragraph">
<p>If the file is unaligned and contains more than one ref block, the ref
index must be written.</p>
</div>
<div class="paragraph">
<p>Index block format:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>'i'
uint24( block_len )
index_record+
uint24( restart_offset )+
uint16( restart_count )

padding?</pre>
</div>
</div>
<div class="paragraph">
<p>The index blocks begin with <span class='synopsis'><code>block_type</code> <code>=</code> <code>i'</code></span> and a 3-byte <span class='synopsis'><code>block_len</code></span>
which encodes the number of bytes in the block, up to but not including
the optional <span class='synopsis'><code>padding</code></span>.</p>
</div>
<div class="paragraph">
<p>The <span class='synopsis'><code>restart_offset</code></span> and <span class='synopsis'><code>restart_count</code></span> fields are identical in format,
meaning and usage as in ref blocks.</p>
</div>
<div class="paragraph">
<p>To reduce the number of reads required for random access in very large
files the index block may be larger than other blocks. However, readers
must hold the entire index in memory to benefit from this, so it&#8217;s a
time-space tradeoff in both file size and reader memory.</p>
</div>
<div class="paragraph">
<p>Increasing the file&#8217;s block size decreases the index size. Alternatively
a multi-level index may be used, keeping index blocks within the file&#8217;s
block size, but increasing the number of blocks that need to be
accessed.</p>
</div>
<div class="sect4">
<h5 id="_index_record"><a class="anchor" href="#_index_record"></a>index record</h5>
<div class="paragraph">
<p>An index record describes the last entry in another block. Index records
are written as:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>varint( prefix_length )
varint( (suffix_length &lt;&lt; 3) | 0 )
suffix
varint( block_position )</pre>
</div>
</div>
<div class="paragraph">
<p>Index records use prefix compression exactly like <span class='synopsis'><code>ref_record</code></span>.</p>
</div>
<div class="paragraph">
<p>Index records store <span class='synopsis'><code>block_position</code></span> after the suffix, specifying the
absolute position in bytes (from the start of the file) of the block
that ends with this reference. Readers can seek to <span class='synopsis'><code>block_position</code></span> to
begin reading the block header.</p>
</div>
<div class="paragraph">
<p>Readers must examine the block header at <span class='synopsis'><code>block_position</code></span> to determine
if the next block is another level index block, or the leaf-level ref
block.</p>
</div>
</div>
<div class="sect4">
<h5 id="_reading_the_index"><a class="anchor" href="#_reading_the_index"></a>Reading the index</h5>
<div class="paragraph">
<p>Readers loading the ref index must first read the footer (below) to
obtain <span class='synopsis'><code>ref_index_position</code></span>. If not present, the position will be 0. The
<span class='synopsis'><code>ref_index_position</code></span> is for the 1st level root of the ref index.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_obj_block_format"><a class="anchor" href="#_obj_block_format"></a>Obj block format</h4>
<div class="paragraph">
<p>Object blocks are optional. Writers may choose to omit object blocks,
especially if readers will not use the object name to ref mapping.</p>
</div>
<div class="paragraph">
<p>Object blocks use unique, abbreviated 2-32 object name keys, mapping to
ref blocks containing references pointing to that object directly, or as
the peeled value of an annotated tag. Like ref blocks, object blocks use
the file&#8217;s standard block size. The abbreviation length is available in
the footer as <span class='synopsis'><code>obj_id_len</code></span>.</p>
</div>
<div class="paragraph">
<p>To save space in small files, object blocks may be omitted if the ref
index is not present, as brute force search will only need to read a few
ref blocks. When missing, readers should brute force a linear search of
all references to lookup by object name.</p>
</div>
<div class="paragraph">
<p>An object block is written as:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>'o'
uint24( block_len )
obj_record+
uint24( restart_offset )+
uint16( restart_count )

padding?</pre>
</div>
</div>
<div class="paragraph">
<p>Fields are identical to ref block. Binary search using the restart table
works the same as in reference blocks.</p>
</div>
<div class="paragraph">
<p>Because object names are abbreviated by writers to the shortest unique
abbreviation within the reftable, obj key lengths have a variable length. Their
length must be at least 2 bytes. Readers must compare only for common prefix
match within an obj block or obj index.</p>
</div>
<div class="sect4">
<h5 id="_obj_record"><a class="anchor" href="#_obj_record"></a>obj record</h5>
<div class="paragraph">
<p>An <span class='synopsis'><code>obj_record</code></span> describes a single object abbreviation, and the blocks
containing references using that unique abbreviation:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>varint( prefix_length )
varint( (suffix_length &lt;&lt; 3) | cnt_3 )
suffix
varint( cnt_large )?
varint( position_delta )*</pre>
</div>
</div>
<div class="paragraph">
<p>Like in reference blocks, abbreviations are prefix compressed within an
obj block. On large reftables with many unique objects, higher block
sizes (64k), and higher restart interval (128), a <span class='synopsis'><code>prefix_length</code></span> of 2
or 3 and <span class='synopsis'><code>suffix_length</code></span> of 3 may be common in obj records (unique
abbreviation of 5-6 raw bytes, 10-12 hex digits).</p>
</div>
<div class="paragraph">
<p>Each record contains <span class='synopsis'><code>position_count</code></span> number of positions for matching
ref blocks. For 1-7 positions the count is stored in <span class='synopsis'><code>cnt_3</code></span>. When
<span class='synopsis'><code>cnt_3</code> <code>=</code> <code>0</code></span> the actual count follows in a varint, <span class='synopsis'><code>cnt_large</code></span>.</p>
</div>
<div class="paragraph">
<p>The use of <span class='synopsis'><code>cnt_3</code></span> bets most objects are pointed to by only a single
reference, some may be pointed to by a couple of references, and very
few (if any) are pointed to by more than 7 references.</p>
</div>
<div class="paragraph">
<p>A special case exists when <span class='synopsis'><code>cnt_3</code> <code>=</code> <code>0</code></span> and <span class='synopsis'><code>cnt_large</code> <code>=</code> <code>0</code></span>: there are no
<span class='synopsis'><code>position_delta</code></span>, but at least one reference starts with this
abbreviation. A reader that needs exact reference names must scan all
references to find which specific references have the desired object.
Writers should use this format when the <span class='synopsis'><code>position_delta</code></span> list would have
overflowed the file&#8217;s block size due to a high number of references
pointing to the same object.</p>
</div>
<div class="paragraph">
<p>The first <span class='synopsis'><code>position_delta</code></span> is the position from the start of the file.
Additional <span class='synopsis'><code>position_delta</code></span> entries are sorted ascending and relative to
the prior entry, e.g. a reader would perform:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>pos = position_delta[0]
prior = pos
for (j = 1; j &lt; position_count; j++) {
  pos = prior + position_delta[j]
  prior = pos
}</pre>
</div>
</div>
<div class="paragraph">
<p>With a position in hand, a reader must linearly scan the ref block,
starting from the first <span class='synopsis'><code>ref_record</code></span>, testing each reference&#8217;s object names
(for <span class='synopsis'><code>value_type</code> <code>=</code> <code>0x1</code></span> or <span class='synopsis'><code>0x2</code></span>) for full equality. Faster searching by
object name within a single ref block is not supported by the reftable format.
Smaller block sizes reduce the number of candidates this step must
consider.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_obj_index"><a class="anchor" href="#_obj_index"></a>Obj index</h4>
<div class="paragraph">
<p>The obj index stores the abbreviation from the last entry for every obj
block in the file, enabling reduced disk seeks for all lookups. It is
formatted exactly the same as the ref index, but refers to obj blocks.</p>
</div>
<div class="paragraph">
<p>The obj index should be present if obj blocks are present, as obj blocks
should only be written in larger files.</p>
</div>
<div class="paragraph">
<p>Readers loading the obj index must first read the footer (below) to
obtain <span class='synopsis'><code>obj_index_position</code></span>. If not present, the position will be 0.</p>
</div>
</div>
<div class="sect3">
<h4 id="_log_block_format"><a class="anchor" href="#_log_block_format"></a>Log block format</h4>
<div class="paragraph">
<p>Unlike ref and obj blocks, log blocks are always unaligned.</p>
</div>
<div class="paragraph">
<p>Log blocks are variable in size, and do not match the <span class='synopsis'><code>block_size</code></span>
specified in the file header or footer. Writers should choose an
appropriate buffer size to prepare a log block for deflation, such as
<span class='synopsis'><code>2</code> <code>*</code> <code>block_size</code></span>.</p>
</div>
<div class="paragraph">
<p>A log block is written as:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>'g'
uint24( block_len )
zlib_deflate {
  log_record+
  uint24( restart_offset )+
  uint16( restart_count )
}</pre>
</div>
</div>
<div class="paragraph">
<p>Log blocks look similar to ref blocks, except <span class='synopsis'><code>block_type</code> <code>=</code> <code>g'</code></span>.</p>
</div>
<div class="paragraph">
<p>The 4-byte block header is followed by the deflated block contents using
zlib deflate. The <span class='synopsis'><code>block_len</code></span> in the header is the inflated size
(including 4-byte block header), and should be used by readers to
preallocate the inflation output buffer. A log block&#8217;s <span class='synopsis'><code>block_len</code></span> may
exceed the file&#8217;s block size.</p>
</div>
<div class="paragraph">
<p>Offsets within the log block (e.g. <span class='synopsis'><code>restart_offset</code></span>) still include the
4-byte header. Readers may prefer prefixing the inflation output buffer
with the 4-byte header.</p>
</div>
<div class="paragraph">
<p>Within the deflate container, a variable number of <span class='synopsis'><code>log_record</code></span> describe
reference changes. The log record format is described below. See ref
block format (above) for a description of <span class='synopsis'><code>restart_offset</code></span> and
<span class='synopsis'><code>restart_count</code></span>.</p>
</div>
<div class="paragraph">
<p>Because log blocks have no alignment or padding between blocks, readers
must keep track of the bytes consumed by the inflater to know where the
next log block begins.</p>
</div>
<div class="sect4">
<h5 id="_log_record"><a class="anchor" href="#_log_record"></a>log record</h5>
<div class="paragraph">
<p>Log record keys are structured as:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>ref_name '\0' reverse_int64( update_index )</pre>
</div>
</div>
<div class="paragraph">
<p>where <span class='synopsis'><code>update_index</code></span> is the unique transaction identifier. The
<span class='synopsis'><code>update_index</code></span> field must be unique within the scope of a <span class='synopsis'><code>ref_name</code></span>.
See the update transactions section below for further details.</p>
</div>
<div class="paragraph">
<p>The <span class='synopsis'><code>reverse_int64</code></span> function inverses the value so lexicographical
ordering the network byte order encoding sorts the more recent records
with higher <span class='synopsis'><code>update_index</code></span> values first:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>reverse_int64(int64 t) {
  return 0xffffffffffffffff - t;
}</pre>
</div>
</div>
<div class="paragraph">
<p>Log records have a similar starting structure to ref and index records,
utilizing the same prefix compression scheme applied to the log record
key described above.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>    varint( prefix_length )
    varint( (suffix_length &lt;&lt; 3) | log_type )
    suffix
    log_data {
      old_id
      new_id
      varint( name_length    )  name
      varint( email_length   )  email
      varint( time_seconds )
      sint16( tz_offset )
      varint( message_length )  message
    }?</pre>
</div>
</div>
<div class="paragraph">
<p>Log record entries use <span class='synopsis'><code>log_type</code></span> to indicate what follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><span class='synopsis'><code>0x0</code></span>: deletion; no log data.</p>
</li>
<li>
<p><span class='synopsis'><code>0x1</code></span>: standard git reflog data using <span class='synopsis'><code>log_data</code></span> above.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <span class='synopsis'><code>log_type</code> <code>=</code> <code>0x0</code></span> is mostly useful for <span class='synopsis'><code>git</code> <code>stash</code> <code>drop</code></span>, removing an
entry from the reflog of <span class='synopsis'><code>refs/stash</code></span> in a transaction file (below),
without needing to rewrite larger files. Readers reading a stack of
reflogs must treat this as a deletion.</p>
</div>
<div class="paragraph">
<p>For <span class='synopsis'><code>log_type</code> <code>=</code> <code>0x1</code></span>, the <span class='synopsis'><code>log_data</code></span> section follows
<a href='{{< relurl "docs/git-update-ref" >}}'>git-update-ref[1]</a> logging and includes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>two object names (old id, new id)</p>
</li>
<li>
<p>varint string of committer&#8217;s name</p>
</li>
<li>
<p>varint string of committer&#8217;s email</p>
</li>
<li>
<p>varint time in seconds since epoch (Jan 1, 1970)</p>
</li>
<li>
<p>2-byte timezone offset in minutes (signed)</p>
</li>
<li>
<p>varint string of message</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><span class='synopsis'><code>tz_offset</code></span> is the absolute number of minutes from GMT the committer was
at the time of the update. For example <span class='synopsis'><code>GMT-0800</code></span> is encoded in reftable
as <span class='synopsis'><code>sint16</code>(<code>-480</code>)</span> and <span class='synopsis'><code>GMT+0230</code></span> is <span class='synopsis'><code>sint16</code>(<code>150</code>)</span>.</p>
</div>
<div class="paragraph">
<p>The committer email does not contain <span class='synopsis'><em>&lt;</em></span> or <span class='synopsis'><em>&gt;</em></span>, it&#8217;s the value normally
found between the <span class='synopsis'><em>&lt;&gt;</em></span> in a git commit object header.</p>
</div>
<div class="paragraph">
<p>The <span class='synopsis'><code>message_length</code></span> may be 0, in which case there was no message
supplied for the update.</p>
</div>
<div class="paragraph">
<p>Contrary to traditional reflog (which is a file), renames are encoded as
a combination of ref deletion and ref creation.  A deletion is a log
record with a zero new_id, and a creation is a log record with a zero old_id.</p>
</div>
</div>
<div class="sect4">
<h5 id="_reading_the_log"><a class="anchor" href="#_reading_the_log"></a>Reading the log</h5>
<div class="paragraph">
<p>Readers accessing the log must first read the footer (below) to
determine the <span class='synopsis'><code>log_position</code></span>. The first block of the log begins at
<span class='synopsis'><code>log_position</code></span> bytes since the start of the file. The <span class='synopsis'><code>log_position</code></span> is
not block aligned.</p>
</div>
</div>
<div class="sect4">
<h5 id="_importing_logs"><a class="anchor" href="#_importing_logs"></a>Importing logs</h5>
<div class="paragraph">
<p>When importing from <span class='synopsis'><code>$GIT_DIR/logs</code></span> writers should globally order all
log records roughly by timestamp while preserving file order, and assign
unique, increasing <span class='synopsis'><code>update_index</code></span> values for each log line. Newer log
records get higher <span class='synopsis'><code>update_index</code></span> values.</p>
</div>
<div class="paragraph">
<p>Although an import may write only a single reftable file, the reftable
file must span many unique <span class='synopsis'><code>update_index</code></span>, as each log line requires its
own <span class='synopsis'><code>update_index</code></span> to preserve semantics.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_log_index"><a class="anchor" href="#_log_index"></a>Log index</h4>
<div class="paragraph">
<p>The log index stores the log key
(<span class='synopsis'><em>refname \0 reverse_int64(update_index)</em></span>) for the last log record of
every log block in the file, supporting bounded-time lookup.</p>
</div>
<div class="paragraph">
<p>A log index block must be written if 2 or more log blocks are written to
the file. If present, the log index appears after the last log block.
There is no padding used to align the log index to block alignment.</p>
</div>
<div class="paragraph">
<p>Log index format is identical to ref index, except the keys are 9 bytes
longer to include <span class='synopsis'><em>'\0'</em></span> and the 8-byte <span class='synopsis'><code>reverse_int64</code>(<code>update_index</code>)</span>.
Records use <span class='synopsis'><code>block_position</code></span> to refer to the start of a log block.</p>
</div>
<div class="sect4">
<h5 id="_reading_the_index_2"><a class="anchor" href="#_reading_the_index_2"></a>Reading the index</h5>
<div class="paragraph">
<p>Readers loading the log index must first read the footer (below) to
obtain <span class='synopsis'><code>log_index_position</code></span>. If not present, the position will be 0.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_footer"><a class="anchor" href="#_footer"></a>Footer</h4>
<div class="paragraph">
<p>After the last block of the file, a file footer is written. It begins
like the file header, but is extended with additional data.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>    HEADER

    uint64( ref_index_position )
    uint64( (obj_position &lt;&lt; 5) | obj_id_len )
    uint64( obj_index_position )

    uint64( log_position )
    uint64( log_index_position )

    uint32( CRC-32 of above )</pre>
</div>
</div>
<div class="paragraph">
<p>If a section is missing (e.g. ref index) the corresponding position
field (e.g. <span class='synopsis'><code>ref_index_position</code></span>) will be 0.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><span class='synopsis'><code>obj_position</code></span>: byte position for the first obj block.</p>
</li>
<li>
<p><span class='synopsis'><code>obj_id_len</code></span>: number of bytes used to abbreviate object names in
obj blocks.</p>
</li>
<li>
<p><span class='synopsis'><code>log_position</code></span>: byte position for the first log block.</p>
</li>
<li>
<p><span class='synopsis'><code>ref_index_position</code></span>: byte position for the start of the ref index.</p>
</li>
<li>
<p><span class='synopsis'><code>obj_index_position</code></span>: byte position for the start of the obj index.</p>
</li>
<li>
<p><span class='synopsis'><code>log_index_position</code></span>: byte position for the start of the log index.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The size of the footer is 68 bytes for version 1, and 72 bytes for
version 2.</p>
</div>
<div class="sect4">
<h5 id="_reading_the_footer"><a class="anchor" href="#_reading_the_footer"></a>Reading the footer</h5>
<div class="paragraph">
<p>Readers must first read the file start to determine the version
number. Then they seek to <span class='synopsis'><code>file_length</code> <code>-</code> <code>FOOTER_LENGTH</code></span> to access the
footer. A trusted external source (such as <span class='synopsis'><code>stat</code>(<code>2</code>)</span>) is necessary to
obtain <span class='synopsis'><code>file_length</code></span>. When reading the footer, readers must verify:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>4-byte magic is correct</p>
</li>
<li>
<p>1-byte version number is recognized</p>
</li>
<li>
<p>4-byte CRC-32 matches the other 64 bytes (including magic, and
version)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Once verified, the other fields of the footer can be accessed.</p>
</div>
</div>
<div class="sect4">
<h5 id="_empty_tables"><a class="anchor" href="#_empty_tables"></a>Empty tables</h5>
<div class="paragraph">
<p>A reftable may be empty. In this case, the file starts with a header
and is immediately followed by a footer.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_binary_search"><a class="anchor" href="#_binary_search"></a>Binary search</h4>
<div class="paragraph">
<p>Binary search within a block is supported by the <span class='synopsis'><code>restart_offset</code></span> fields
at the end of the block. Readers can binary search through the restart
table to locate between which two restart points the sought reference or
key should appear.</p>
</div>
<div class="paragraph">
<p>Each record identified by a <span class='synopsis'><code>restart_offset</code></span> stores the complete key in
the <span class='synopsis'><code>suffix</code></span> field of the record, making the compare operation during
binary search straightforward.</p>
</div>
<div class="paragraph">
<p>Once a restart point lexicographically before the sought reference has
been identified, readers can linearly scan through the following record
entries to locate the sought record, terminating if the current record
sorts after (and therefore the sought key is not present).</p>
</div>
<div class="sect4">
<h5 id="_restart_point_selection"><a class="anchor" href="#_restart_point_selection"></a>Restart point selection</h5>
<div class="paragraph">
<p>Writers determine the restart points at file creation. The process is
arbitrary, but every 16 or 64 records is recommended. Every 16 may be
more suitable for smaller block sizes (4k or 8k), every 64 for larger
block sizes (64k).</p>
</div>
<div class="paragraph">
<p>More frequent restart points reduces prefix compression and increases
space consumed by the restart table, both of which increase file size.</p>
</div>
<div class="paragraph">
<p>Less frequent restart points makes prefix compression more effective,
decreasing overall file size, with increased penalties for readers
walking through more records after the binary search step.</p>
</div>
<div class="paragraph">
<p>A maximum of <span class='synopsis'><code>65535</code></span> restart points per block is supported.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_considerations"><a class="anchor" href="#_considerations"></a>Considerations</h3>
<div class="sect3">
<h4 id="_lightweight_refs_dominate"><a class="anchor" href="#_lightweight_refs_dominate"></a>Lightweight refs dominate</h4>
<div class="paragraph">
<p>The reftable format assumes the vast majority of references are single
object names valued with common prefixes, such as Gerrit Code Review&#8217;s
<span class='synopsis'><code>refs/changes/</code></span> namespace, GitHub&#8217;s <span class='synopsis'><code>refs/pulls/</code></span> namespace, or many
lightweight tags in the <span class='synopsis'><code>refs/tags/</code></span> namespace.</p>
</div>
<div class="paragraph">
<p>Annotated tags storing the peeled object cost an additional object name per
reference.</p>
</div>
</div>
<div class="sect3">
<h4 id="_low_overhead"><a class="anchor" href="#_low_overhead"></a>Low overhead</h4>
<div class="paragraph">
<p>A reftable with very few references (e.g. git.git with 5 heads) is 269
bytes for reftable, vs. 332 bytes for packed-refs. This supports
reftable scaling down for transaction logs (below).</p>
</div>
</div>
<div class="sect3">
<h4 id="_block_size_2"><a class="anchor" href="#_block_size_2"></a>Block size</h4>
<div class="paragraph">
<p>For a Gerrit Code Review type repository with many change refs, larger
block sizes (64 KiB) and less frequent restart points (every 64) yield
better compression due to more references within the block compressing
against the prior reference.</p>
</div>
<div class="paragraph">
<p>Larger block sizes reduce the index size, as the reftable will require
fewer blocks to store the same number of references.</p>
</div>
</div>
<div class="sect3">
<h4 id="_minimal_disk_seeks"><a class="anchor" href="#_minimal_disk_seeks"></a>Minimal disk seeks</h4>
<div class="paragraph">
<p>Assuming the index block has been loaded into memory, binary searching
for any single reference requires exactly 1 disk seek to load the
containing block.</p>
</div>
</div>
<div class="sect3">
<h4 id="_scans_and_lookups_dominate"><a class="anchor" href="#_scans_and_lookups_dominate"></a>Scans and lookups dominate</h4>
<div class="paragraph">
<p>Scanning all references and lookup by name (or namespace such as
<span class='synopsis'><code>refs/heads/</code></span>) are the most common activities performed on repositories.
Object names are stored directly with references to optimize this use case.</p>
</div>
</div>
<div class="sect3">
<h4 id="_logs_are_infrequently_read"><a class="anchor" href="#_logs_are_infrequently_read"></a>Logs are infrequently read</h4>
<div class="paragraph">
<p>Logs are infrequently accessed, but can be large. Deflating log blocks
saves disk space, with some increased penalty at read time.</p>
</div>
<div class="paragraph">
<p>Logs are stored in an isolated section from refs, reducing the burden on
reference readers that want to ignore logs. Further, historical logs can
be isolated into log-only files.</p>
</div>
</div>
<div class="sect3">
<h4 id="_logs_are_read_backwards"><a class="anchor" href="#_logs_are_read_backwards"></a>Logs are read backwards</h4>
<div class="paragraph">
<p>Logs are frequently accessed backwards (most recent N records for master
to answer <span class='synopsis'><code>master@{4}</code></span>), so log records are grouped by reference, and
sorted descending by update index.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_repository_format"><a class="anchor" href="#_repository_format"></a>Repository format</h3>
<div class="sect3">
<h4 id="_version_1"><a class="anchor" href="#_version_1"></a>Version 1</h4>
<div class="paragraph">
<p>A repository must set its <span class='synopsis'><code>$GIT_DIR/config</code></span> to configure reftable:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>[core]
    repositoryformatversion = 1
[extensions]
    refStorage = reftable</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_layout"><a class="anchor" href="#_layout"></a>Layout</h4>
<div class="paragraph">
<p>A collection of reftable files are stored in the <span class='synopsis'><code>$GIT_DIR/reftable/</code></span> directory.
Their names should have a random element, such that each filename is globally
unique; this helps avoid spurious failures on Windows, where open files cannot
be removed or overwritten. It suggested to use
<span class='synopsis'><code>${min_update_index}-${max_update_index}-${random}.ref</code></span> as a naming convention.</p>
</div>
<div class="paragraph">
<p>Log-only files use the <span class='synopsis'><code>.log</code></span> extension, while ref-only and mixed ref
and log files use <span class='synopsis'><code>.ref</code></span>. extension.</p>
</div>
<div class="paragraph">
<p>The stack ordering file is <span class='synopsis'><code>$GIT_DIR/reftable/tables.list</code></span> and lists the
current files, one per line, in order, from oldest (base) to newest
(most recent):</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ cat .git/reftable/tables.list
00000001-00000001-RANDOM1.log
00000002-00000002-RANDOM2.ref
00000003-00000003-RANDOM3.ref</pre>
</div>
</div>
<div class="paragraph">
<p>Readers must read <span class='synopsis'><code>$GIT_DIR/reftable/tables.list</code></span> to determine which
files are relevant right now, and search through the stack in reverse
order (last reftable is examined first).</p>
</div>
<div class="paragraph">
<p>Reftable files not listed in <span class='synopsis'><code>tables.list</code></span> may be new (and about to be
added to the stack by the active writer), or ancient and ready to be
pruned.</p>
</div>
</div>
<div class="sect3">
<h4 id="_backward_compatibility"><a class="anchor" href="#_backward_compatibility"></a>Backward compatibility</h4>
<div class="paragraph">
<p>Older clients should continue to recognize the directory as a git
repository so they don&#8217;t look for an enclosing repository in parent
directories. To this end, a reftable-enabled repository must contain the
following dummy files</p>
</div>
<div class="ulist">
<ul>
<li>
<p><span class='synopsis'><code>.git/HEAD</code></span>, a regular file containing <span class='synopsis'><code>ref:</code> <code>refs/heads/.invalid</code></span>.</p>
</li>
<li>
<p><span class='synopsis'><code>.git/refs/</code></span>, a directory</p>
</li>
<li>
<p><span class='synopsis'><code>.git/refs/heads</code></span>, a regular file</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_readers"><a class="anchor" href="#_readers"></a>Readers</h4>
<div class="paragraph">
<p>Readers can obtain a consistent snapshot of the reference space by
following:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Open and read the <span class='synopsis'><code>tables.list</code></span> file.</p>
</li>
<li>
<p>Open each of the reftable files that it mentions.</p>
</li>
<li>
<p>If any of the files is missing, goto 1.</p>
</li>
<li>
<p>Read from the now-open files as long as necessary.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_update_transactions"><a class="anchor" href="#_update_transactions"></a>Update transactions</h4>
<div class="paragraph">
<p>Although reftables are immutable, mutations are supported by writing a
new reftable and atomically appending it to the stack:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Acquire <span class='synopsis'><code>tables.list.lock</code></span>.</p>
</li>
<li>
<p>Read <span class='synopsis'><code>tables.list</code></span> to determine current reftables.</p>
</li>
<li>
<p>Select <span class='synopsis'><code>update_index</code></span> to be most recent file&#8217;s
<span class='synopsis'><code>max_update_index</code> <code>+</code> <code>1</code></span>.</p>
</li>
<li>
<p>Prepare temp reftable <span class='synopsis'><code>tmp_XXXXXX</code></span>, including log entries.</p>
</li>
<li>
<p>Rename <span class='synopsis'><code>tmp_XXXXXX</code></span> to <span class='synopsis'><code>${update_index}-${update_index}-${random}.ref</code></span>.</p>
</li>
<li>
<p>Copy <span class='synopsis'><code>tables.list</code></span> to <span class='synopsis'><code>tables.list.lock</code></span>, appending file from (5).</p>
</li>
<li>
<p>Rename <span class='synopsis'><code>tables.list.lock</code></span> to <span class='synopsis'><code>tables.list</code></span>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>During step 4 the new file&#8217;s <span class='synopsis'><code>min_update_index</code></span> and <span class='synopsis'><code>max_update_index</code></span>
are both set to the <span class='synopsis'><code>update_index</code></span> selected by step 3. All log records
for the transaction use the same <span class='synopsis'><code>update_index</code></span> in their keys. This
enables later correlation of which references were updated by the same
transaction.</p>
</div>
<div class="paragraph">
<p>Because a single <span class='synopsis'><code>tables.list.lock</code></span> file is used to manage locking, the
repository is single-threaded for writers. Writers may have to busy-spin
(with backoff) around creating <span class='synopsis'><code>tables.list.lock</code></span>, for up to an
acceptable wait period, aborting if the repository is too busy to
mutate. Application servers wrapped around repositories (e.g. Gerrit
Code Review) can layer their own lock/wait queue to improve fairness to
writers.</p>
</div>
</div>
<div class="sect3">
<h4 id="_reference_deletions"><a class="anchor" href="#_reference_deletions"></a>Reference deletions</h4>
<div class="paragraph">
<p>Deletion of any reference can be explicitly stored by setting the <span class='synopsis'><code>type</code></span>
to <span class='synopsis'><code>0x0</code></span> and omitting the <span class='synopsis'><code>value</code></span> field of the <span class='synopsis'><code>ref_record</code></span>. This serves
as a tombstone, overriding any assertions about the existence of the
reference from earlier files in the stack.</p>
</div>
</div>
<div class="sect3">
<h4 id="_compaction"><a class="anchor" href="#_compaction"></a>Compaction</h4>
<div class="paragraph">
<p>A partial stack of reftables can be compacted by merging references
using a straightforward merge join across reftables, selecting the most
recent value for output, and omitting deleted references that do not
appear in remaining, lower reftables.</p>
</div>
<div class="paragraph">
<p>A compacted reftable should set its <span class='synopsis'><code>min_update_index</code></span> to the smallest
of the input files' <span class='synopsis'><code>min_update_index</code></span>, and its <span class='synopsis'><code>max_update_index</code></span>
likewise to the largest input <span class='synopsis'><code>max_update_index</code></span>.</p>
</div>
<div class="paragraph">
<p>For sake of illustration, assume the stack currently consists of
reftable files (from oldest to newest): A, B, C, and D. The compactor is
going to compact B and C, leaving A and D alone.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Obtain lock <span class='synopsis'><code>tables.list.lock</code></span> and read the <span class='synopsis'><code>tables.list</code></span> file.</p>
</li>
<li>
<p>Obtain locks <span class='synopsis'><code>B.lock</code></span> and <span class='synopsis'><code>C.lock</code></span>. Ownership of these locks
prevents other processes from trying to compact these files.</p>
</li>
<li>
<p>Release <span class='synopsis'><code>tables.list.lock</code></span>.</p>
</li>
<li>
<p>Compact <span class='synopsis'><code>B</code></span> and <span class='synopsis'><code>C</code></span> into a temp file
<span class='synopsis'><code>${min_update_index}-${max_update_index}_XXXXXX</code></span>.</p>
</li>
<li>
<p>Reacquire lock <span class='synopsis'><code>tables.list.lock</code></span>.</p>
</li>
<li>
<p>Verify that <span class='synopsis'><code>B</code></span> and <span class='synopsis'><code>C</code></span> are still in the stack, in that order. This
should always be the case, assuming that other processes are adhering to
the locking protocol.</p>
</li>
<li>
<p>Rename <span class='synopsis'><code>${min_update_index}-${max_update_index}_XXXXXX</code></span> to
<span class='synopsis'><code>${min_update_index}-${max_update_index}-${random}.ref</code></span>.</p>
</li>
<li>
<p>Write the new stack to <span class='synopsis'><code>tables.list.lock</code></span>, replacing <span class='synopsis'><code>B</code></span> and <span class='synopsis'><code>C</code></span>
with the file from (4).</p>
</li>
<li>
<p>Rename <span class='synopsis'><code>tables.list.lock</code></span> to <span class='synopsis'><code>tables.list</code></span>.</p>
</li>
<li>
<p>Delete <span class='synopsis'><code>B</code></span> and <span class='synopsis'><code>C</code></span>, perhaps after a short sleep to avoid forcing
readers to backtrack.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>This strategy permits compactions to proceed independently of updates.</p>
</div>
<div class="paragraph">
<p>Each reftable (compacted or not) is uniquely identified by its name, so
open reftables can be cached by their name.</p>
</div>
</div>
<div class="sect3">
<h4 id="_windows"><a class="anchor" href="#_windows"></a>Windows</h4>
<div class="paragraph">
<p>On windows, and other systems that do not allow deleting or renaming to open
files, compaction may succeed, but other readers may prevent obsolete tables
from being deleted.</p>
</div>
<div class="paragraph">
<p>On these platforms, the following strategy can be followed: on closing a
reftable stack, reload <span class='synopsis'><code>tables.list</code></span>, and delete any tables no longer mentioned
in <span class='synopsis'><code>tables.list</code></span>.</p>
</div>
<div class="paragraph">
<p>Irregular program exit may still leave about unused files. In this case, a
cleanup operation should proceed as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>take a lock <span class='synopsis'><code>tables.list.lock</code></span> to prevent concurrent modifications</p>
</li>
<li>
<p>refresh the reftable stack, by reading <span class='synopsis'><code>tables.list</code></span></p>
</li>
<li>
<p>for each <span class='synopsis'><code>*.ref</code></span> file, remove it if</p>
<div class="ulist">
<ul>
<li>
<p>it is not mentioned in <span class='synopsis'><code>tables.list</code></span>, and</p>
</li>
<li>
<p>its max update_index is not beyond the max update_index of the stack</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_alternatives_considered"><a class="anchor" href="#_alternatives_considered"></a>Alternatives considered</h3>
<div class="sect3">
<h4 id="_bzip_packed_refs"><a class="anchor" href="#_bzip_packed_refs"></a>bzip packed-refs</h4>
<div class="paragraph">
<p><span class='synopsis'><code>bzip2</code></span> can significantly shrink a large packed-refs file (e.g. 62 MiB
compresses to 23 MiB, 37%). However the bzip format does not support
random access to a single reference. Readers must inflate and discard
while performing a linear scan.</p>
</div>
<div class="paragraph">
<p>Breaking packed-refs into chunks (individually compressing each chunk)
would reduce the amount of data a reader must inflate, but still leaves
the problem of indexing chunks to support readers efficiently locating
the correct chunk.</p>
</div>
<div class="paragraph">
<p>Given the compression achieved by reftable&#8217;s encoding, it does not seem
necessary to add the complexity of bzip/gzip/zlib.</p>
</div>
</div>
<div class="sect3">
<h4 id="_michael_haggertys_alternate_format"><a class="anchor" href="#_michael_haggertys_alternate_format"></a>Michael Haggerty&#8217;s alternate format</h4>
<div class="paragraph">
<p>Michael Haggerty proposed
<a href="https://lore.kernel.org/git/CAMy9T_HCnyc1g8XWOOWhe7nN0aEFyyBskV2aOMb_fe%2BwGvEJ7A%40mail.gmail.com/">an
alternate</a> format to reftable on the Git mailing list. This format uses
smaller chunks, without the restart table, and avoids block alignment
with padding. Reflog entries immediately follow each ref, and are thus
interleaved between refs.</p>
</div>
<div class="paragraph">
<p>Performance testing indicates reftable is faster for lookups (51%
faster, 11.2 usec vs. 5.4 usec), although reftable produces a slightly
larger file (+ ~3.2%, 28.3M vs 29.2M):</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-right valign-top">format</th>
<th class="tableblock halign-right valign-top">size</th>
<th class="tableblock halign-right valign-top">seek cold</th>
<th class="tableblock halign-right valign-top">seek hot</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-right valign-top"><p class="tableblock">mh-alt</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">28.3 M</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">23.4 usec</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">11.2 usec</p></td>
</tr>
<tr>
<td class="tableblock halign-right valign-top"><p class="tableblock">reftable</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">29.2 M</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">19.9 usec</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">5.4 usec</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_jgit_ketch_reftree"><a class="anchor" href="#_jgit_ketch_reftree"></a>JGit Ketch RefTree</h4>
<div class="paragraph">
<p><a href="https://dev.eclipse.org/mhonarc/lists/jgit-dev/msg03073.html">JGit Ketch</a>
proposed
<a href="https://lore.kernel.org/git/CAJo%3DhJvnAPNAdDcAAwAvU9C4RVeQdoS3Ev9WTguHx4fD0V_nOg%40mail.gmail.com/">RefTree</a>,
an encoding of references inside Git tree objects stored as part of the
repository&#8217;s object database.</p>
</div>
<div class="paragraph">
<p>The RefTree format adds additional load on the object database storage
layer (more loose objects, more objects in packs), and relies heavily on
the packer&#8217;s delta compression to save space. Namespaces which are flat
(e.g. thousands of tags in refs/tags) initially create very large loose
objects, and so RefTree does not address the problem of copying many
references to modify a handful.</p>
</div>
<div class="paragraph">
<p>Flat namespaces are not efficiently searchable in RefTree, as tree
objects in canonical formatting cannot be binary searched. This fails
the need to handle a large number of references in a single namespace,
such as GitHub&#8217;s <span class='synopsis'><code>refs/pulls</code></span>, or a project with many tags.</p>
</div>
</div>
<div class="sect3">
<h4 id="_lmdb"><a class="anchor" href="#_lmdb"></a>LMDB</h4>
<div class="paragraph">
<p>David Turner proposed
<a href="https://lore.kernel.org/git/1455772670-21142-26-git-send-email-dturner@twopensource.com/">using
LMDB</a>, as LMDB is lightweight (64k of runtime code) and GPL-compatible
license.</p>
</div>
<div class="paragraph">
<p>A downside of LMDB is its reliance on a single C implementation. This
makes embedding inside JGit (a popular reimplementation of Git)
difficult, and hoisting onto virtual storage (for JGit DFS) virtually
impossible.</p>
</div>
<div class="paragraph">
<p>A common format that can be supported by all major Git implementations
(git-core, JGit, libgit2) is strongly preferred.</p>
</div>
</div>
</div>
</div>
</div>