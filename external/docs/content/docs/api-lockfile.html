---
### DO NOT EDIT! Generated by script/update-docs.rb

category: manual
section: documentation
subsection: manual
title: Git - api-lockfile Documentation
docname: api-lockfile
version: 2.2.3
latest-changes: 2.2.3
aliases:
- "/docs/api-lockfile/index.html"
---
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>The lockfile API serves two purposes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Mutual exclusion and atomic file updates. When we want to change a
file, we create a lockfile <span class='synopsis'><em>&lt;filename&gt;</em><code>.lock</code></span>, write the new file
contents into it, and then rename the lockfile to its final
destination <span class='synopsis'><em>&lt;filename&gt;</em></span>. We create the <span class='synopsis'><em>&lt;filename&gt;</em><code>.lock</code></span> file with
<span class='synopsis'><code>O_CREAT</code>|<code>O_EXCL</code></span> so that we can notice and fail if somebody else has
already locked the file, then atomically rename the lockfile to its
final destination to commit the changes and unlock the file.</p>
</li>
<li>
<p>Automatic cruft removal. If the program exits after we lock a file
but before the changes have been committed, we want to make sure
that we remove the lockfile. This is done by remembering the
lockfiles we have created in a linked list and setting up an
<span class='synopsis'><code>atexit</code>(<code>3</code>)</span> handler and a signal handler that clean up the
lockfiles. This mechanism ensures that outstanding lockfiles are
cleaned up if the program exits (including when <span class='synopsis'><code>die</code>()</span> is called)
or if the program dies on a signal.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Please note that lockfiles only block other writers. Readers do not
block, but they are guaranteed to see either the old contents of the
file or the new contents of the file (assuming that the filesystem
implements <span class='synopsis'><code>rename</code>(<code>2</code>)</span> atomically).</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_calling_sequence"><a class="anchor" href="#_calling_sequence"></a>Calling sequence</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The caller:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Allocates a <span class='synopsis'><code>struct</code> <code>lock_file</code></span> either as a static variable or on the
heap, initialized to zeros. Once you use the structure to call the
<span class='synopsis'><code>hold_lock_file_*</code></span> family of functions, it belongs to the lockfile
subsystem and its storage must remain valid throughout the life of
the program (i.e. you cannot use an on-stack variable to hold this
structure).</p>
</li>
<li>
<p>Attempts to create a lockfile by passing that variable and the path
of the final destination (e.g. <span class='synopsis'><code>$GIT_DIR/index</code></span>) to
<span class='synopsis'><code>hold_lock_file_for_update</code></span> or <span class='synopsis'><code>hold_lock_file_for_append</code></span>.</p>
</li>
<li>
<p>Writes new content for the destination file by either:</p>
</li>
<li>
<p>writing to the file descriptor returned by the <span class='synopsis'><code>hold_lock_file_*</code></span>
functions (also available via <span class='synopsis'><em>lock-&gt;fd</em></span>).</p>
</li>
<li>
<p>calling <span class='synopsis'><code>fdopen_lock_file</code></span> to get a <span class='synopsis'><code>FILE</code></span> pointer for the open
file and writing to the file using stdio.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When finished writing, the caller can:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Close the file descriptor and rename the lockfile to its final
destination by calling <span class='synopsis'><code>commit_lock_file</code></span> or <span class='synopsis'><code>commit_lock_file_to</code></span>.</p>
</li>
<li>
<p>Close the file descriptor and remove the lockfile by calling
<span class='synopsis'><code>rollback_lock_file</code></span>.</p>
</li>
<li>
<p>Close the file descriptor without removing or renaming the lockfile
by calling <span class='synopsis'><code>close_lock_file</code></span>, and later call <span class='synopsis'><code>commit_lock_file</code></span>,
<span class='synopsis'><code>commit_lock_file_to</code></span>, <span class='synopsis'><code>rollback_lock_file</code></span>, or <span class='synopsis'><code>reopen_lock_file</code></span>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Even after the lockfile is committed or rolled back, the <span class='synopsis'><code>lock_file</code></span>
object must not be freed or altered by the caller. However, it may be
reused; just pass it to another call of <span class='synopsis'><code>hold_lock_file_for_update</code></span> or
<span class='synopsis'><code>hold_lock_file_for_append</code></span>.</p>
</div>
<div class="paragraph">
<p>If the program exits before you have called one of <span class='synopsis'><code>commit_lock_file</code></span>,
<span class='synopsis'><code>commit_lock_file_to</code></span>, <span class='synopsis'><code>rollback_lock_file</code></span>, or <span class='synopsis'><code>close_lock_file</code></span>, an
<span class='synopsis'><code>atexit</code>(<code>3</code>)</span> handler will close and remove the lockfile, rolling back
any uncommitted changes.</p>
</div>
<div class="paragraph">
<p>If you need to close the file descriptor you obtained from a
<span class='synopsis'><code>hold_lock_file_*</code></span> function yourself, do so by calling
<span class='synopsis'><code>close_lock_file</code></span>. You should never call <span class='synopsis'><code>close</code>(<code>2</code>)</span> or <span class='synopsis'><code>fclose</code>(<code>3</code>)</span>
yourself! Otherwise the <span class='synopsis'><code>struct</code> <code>lock_file</code></span> structure would still think
that the file descriptor needs to be closed, and a commit or rollback
would result in duplicate calls to <span class='synopsis'><code>close</code>(<code>2</code>)</span>. Worse yet, if you close
and then later open another file descriptor for a completely different
purpose, then a commit or rollback might close that unrelated file
descriptor.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_error_handling"><a class="anchor" href="#_error_handling"></a>Error handling</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <span class='synopsis'><code>hold_lock_file_*</code></span> functions return a file descriptor on success
or -1 on failure (unless <span class='synopsis'><code>LOCK_DIE_ON_ERROR</code></span> is used; see below). On
errors, <span class='synopsis'><code>errno</code></span> describes the reason for failure. Errors can be
reported by passing <span class='synopsis'><code>errno</code></span> to one of the following helper functions:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1" id="Documentation/technical/api-lockfile.txt-unabletolockmessage"><a class="anchor" href="#Documentation/technical/api-lockfile.txt-unabletolockmessage"></a>unable_to_lock_message </dt>
<dd>
<p>Append an appropriate error message to a <span class='synopsis'><code>strbuf</code></span>.</p>
</dd>
<dt class="hdlist1" id="Documentation/technical/api-lockfile.txt-unabletolockerror"><a class="anchor" href="#Documentation/technical/api-lockfile.txt-unabletolockerror"></a>unable_to_lock_error </dt>
<dd>
<p>Emit an appropriate error message using <span class='synopsis'><code>error</code>()</span>.</p>
</dd>
<dt class="hdlist1" id="Documentation/technical/api-lockfile.txt-unabletolockdie"><a class="anchor" href="#Documentation/technical/api-lockfile.txt-unabletolockdie"></a>unable_to_lock_die </dt>
<dd>
<p>Emit an appropriate error message and <span class='synopsis'><code>die</code>()</span>.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Similarly, <span class='synopsis'><code>commit_lock_file</code></span>, <span class='synopsis'><code>commit_lock_file_to</code></span>, and
<span class='synopsis'><code>close_lock_file</code></span> return 0 on success. On failure they set <span class='synopsis'><code>errno</code></span>
appropriately, do their best to roll back the lockfile, and return -1.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_flags"><a class="anchor" href="#_flags"></a>Flags</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The following flags can be passed to <span class='synopsis'><code>hold_lock_file_for_update</code></span> or
<span class='synopsis'><code>hold_lock_file_for_append</code></span>:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1" id="Documentation/technical/api-lockfile.txt-LOCKNODEREF"><a class="anchor" href="#Documentation/technical/api-lockfile.txt-LOCKNODEREF"></a>LOCK_NO_DEREF </dt>
<dd>
<p>Usually symbolic links in the destination path are resolved
and the lockfile is created by adding ".lock" to the resolved
path. If <span class='synopsis'><code>LOCK_NO_DEREF</code></span> is set, then the lockfile is created
by adding ".lock" to the path argument itself. This option is
used, for example, when locking a symbolic reference, which
for backwards-compatibility reasons can be a symbolic link
containing the name of the referred-to-reference.</p>
</dd>
<dt class="hdlist1" id="Documentation/technical/api-lockfile.txt-LOCKDIEONERROR"><a class="anchor" href="#Documentation/technical/api-lockfile.txt-LOCKDIEONERROR"></a>LOCK_DIE_ON_ERROR </dt>
<dd>
<p>If a lock is already taken for the file, <span class='synopsis'><code>die</code>()</span> with an error
message. If this option is not specified, trying to lock a
file that is already locked returns -1 to the caller.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_the_functions"><a class="anchor" href="#_the_functions"></a>The functions</h2>
<div class="sectionbody">
<div class="dlist">
<dl>
<dt class="hdlist1" id="Documentation/technical/api-lockfile.txt-holdlockfileforupdate"><a class="anchor" href="#Documentation/technical/api-lockfile.txt-holdlockfileforupdate"></a>hold_lock_file_for_update </dt>
<dd>
<p>Take a pointer to <span class='synopsis'><code>struct</code> <code>lock_file</code></span>, the path of the file to
be locked (e.g. <span class='synopsis'><code>$GIT_DIR/index</code></span>) and a flags argument (see
above). Attempt to create a lockfile for the destination and
return the file descriptor for writing to the file.</p>
</dd>
<dt class="hdlist1" id="Documentation/technical/api-lockfile.txt-holdlockfileforappend"><a class="anchor" href="#Documentation/technical/api-lockfile.txt-holdlockfileforappend"></a>hold_lock_file_for_append </dt>
<dd>
<p>Like <span class='synopsis'><code>hold_lock_file_for_update</code></span>, but before returning copy
the existing contents of the file (if any) to the lockfile and
position its write pointer at the end of the file.</p>
</dd>
<dt class="hdlist1" id="Documentation/technical/api-lockfile.txt-fdopenlockfile"><a class="anchor" href="#Documentation/technical/api-lockfile.txt-fdopenlockfile"></a>fdopen_lock_file </dt>
<dd>
<p>Associate a stdio stream with the lockfile. Return NULL
(<strong>without</strong> rolling back the lockfile) on error. The stream is
closed automatically when <span class='synopsis'><code>close_lock_file</code></span> is called or when
the file is committed or rolled back.</p>
</dd>
<dt class="hdlist1" id="Documentation/technical/api-lockfile.txt-getlockedfilepath"><a class="anchor" href="#Documentation/technical/api-lockfile.txt-getlockedfilepath"></a>get_locked_file_path </dt>
<dd>
<p>Return the path of the file that is locked by the specified
lock_file object. The caller must free the memory.</p>
</dd>
<dt class="hdlist1" id="Documentation/technical/api-lockfile.txt-commitlockfile"><a class="anchor" href="#Documentation/technical/api-lockfile.txt-commitlockfile"></a>commit_lock_file </dt>
<dd>
<p>Take a pointer to the <span class='synopsis'><code>struct</code> <code>lock_file</code></span> initialized with an
earlier call to <span class='synopsis'><code>hold_lock_file_for_update</code></span> or
<span class='synopsis'><code>hold_lock_file_for_append</code></span>, close the file descriptor, and
rename the lockfile to its final destination. Return 0 upon
success. On failure, roll back the lock file and return -1,
with <span class='synopsis'><code>errno</code></span> set to the value from the failing call to
<span class='synopsis'><code>close</code>(<code>2</code>)</span> or <span class='synopsis'><code>rename</code>(<code>2</code>)</span>. It is a bug to call
<span class='synopsis'><code>commit_lock_file</code></span> for a <span class='synopsis'><code>lock_file</code></span> object that is not
currently locked.</p>
</dd>
<dt class="hdlist1" id="Documentation/technical/api-lockfile.txt-commitlockfileto"><a class="anchor" href="#Documentation/technical/api-lockfile.txt-commitlockfileto"></a>commit_lock_file_to </dt>
<dd>
<p>Like <span class='synopsis'><code>commit_lock_file</code>()</span>, except that it takes an explicit
<span class='synopsis'><code>path</code></span> argument to which the lockfile should be renamed. The
<span class='synopsis'><code>path</code></span> must be on the same filesystem as the lock file.</p>
</dd>
<dt class="hdlist1" id="Documentation/technical/api-lockfile.txt-rollbacklockfile"><a class="anchor" href="#Documentation/technical/api-lockfile.txt-rollbacklockfile"></a>rollback_lock_file </dt>
<dd>
<p>Take a pointer to the <span class='synopsis'><code>struct</code> <code>lock_file</code></span> initialized with an
earlier call to <span class='synopsis'><code>hold_lock_file_for_update</code></span> or
<span class='synopsis'><code>hold_lock_file_for_append</code></span>, close the file descriptor and
remove the lockfile. It is a NOOP to call
<span class='synopsis'><code>rollback_lock_file</code>()</span> for a <span class='synopsis'><code>lock_file</code></span> object that has
already been committed or rolled back.</p>
</dd>
<dt class="hdlist1" id="Documentation/technical/api-lockfile.txt-closelockfile"><a class="anchor" href="#Documentation/technical/api-lockfile.txt-closelockfile"></a>close_lock_file </dt>
<dd>
<p>Take a pointer to the <span class='synopsis'><code>struct</code> <code>lock_file</code></span> initialized with an
earlier call to <span class='synopsis'><code>hold_lock_file_for_update</code></span> or
<span class='synopsis'><code>hold_lock_file_for_append</code></span>. Close the file descriptor (and
the file pointer if it has been opened using
<span class='synopsis'><code>fdopen_lock_file</code></span>). Return 0 upon success. On failure to
<span class='synopsis'><code>close</code>(<code>2</code>)</span>, return a negative value and roll back the lock
file. Usually <span class='synopsis'><code>commit_lock_file</code></span>, <span class='synopsis'><code>commit_lock_file_to</code></span>, or
<span class='synopsis'><code>rollback_lock_file</code></span> should eventually be called if
<span class='synopsis'><code>close_lock_file</code></span> succeeds.</p>
</dd>
<dt class="hdlist1" id="Documentation/technical/api-lockfile.txt-reopenlockfile"><a class="anchor" href="#Documentation/technical/api-lockfile.txt-reopenlockfile"></a>reopen_lock_file </dt>
<dd>
<p>Re-open a lockfile that has been closed (using
<span class='synopsis'><code>close_lock_file</code></span>) but not yet committed or rolled back. This
can be used to implement a sequence of operations like the
following:</p>
<div class="ulist">
<ul>
<li>
<p>Lock file.</p>
</li>
<li>
<p>Write new contents to lockfile, then <span class='synopsis'><code>close_lock_file</code></span> to
cause the contents to be written to disk.</p>
</li>
<li>
<p>Pass the name of the lockfile to another program to allow it
(and nobody else) to inspect the contents you wrote, while
still holding the lock yourself.</p>
</li>
<li>
<p><span class='synopsis'><code>reopen_lock_file</code></span> to reopen the lockfile. Make further
updates to the contents.</p>
</li>
<li>
<p><span class='synopsis'><code>commit_lock_file</code></span> to make the final version permanent.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>