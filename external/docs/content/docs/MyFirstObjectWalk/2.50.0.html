---
### DO NOT EDIT! Generated by script/update-docs.rb

category: manual
section: documentation
subsection: manual
title: Git - MyFirstObjectWalk Documentation
docname: MyFirstObjectWalk
version: 2.50.0
aliases:
- "/docs/MyFirstObjectWalk/2.50.0/index.html"
---
<div class="sect1">
<h2 id="_whats_an_object_walk"><a class="anchor" href="#_whats_an_object_walk"></a>What&#8217;s an Object Walk?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The object walk is a key concept in Git - this is the process that underpins
operations like object transfer and fsck. Beginning from a given commit, the
list of objects is found by walking parent relationships between commits (commit
X based on commit W) and containment relationships between objects (tree Y is
contained within commit X, and blob Z is located within tree Y, giving our
working tree for commit X something like <span class='synopsis'><code>y/z.txt</code></span>).</p>
</div>
<div class="paragraph">
<p>A related concept is the revision walk, which is focused on commit objects and
their parent relationships and does not delve into other object types. The
revision walk is used for operations like <span class='synopsis'><code>git</code> <code>log</code></span>.</p>
</div>
<div class="sect2">
<h3 id="_related_reading"><a class="anchor" href="#_related_reading"></a>Related Reading</h3>
<div class="ulist">
<ul>
<li>
<p><span class='synopsis'><code>Documentation/user-manual.adoc</code></span> under "Hacking Git" contains some coverage of
the revision walker in its various incarnations.</p>
</li>
<li>
<p><span class='synopsis'><code>revision.h</code></span></p>
</li>
<li>
<p><a href="https://eagain.net/articles/git-for-computer-scientists/">Git for Computer Scientists</a>
gives a good overview of the types of objects in Git and what your object
walk is really describing.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_setting_up"><a class="anchor" href="#_setting_up"></a>Setting Up</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Create a new branch from <span class='synopsis'><code>master</code></span>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>git checkout -b revwalk origin/master</pre>
</div>
</div>
<div class="paragraph">
<p>We&#8217;ll put our fiddling into a new command. For fun, let&#8217;s name it <span class='synopsis'><code>git</code> <code>walken</code></span>.
Open up a new file <span class='synopsis'><code>builtin/walken.c</code></span> and set up the command handler:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>/*
 * "git walken"
 *
 * Part of the "My First Object Walk" tutorial.
 */

#include "builtin.h"
#include "trace.h"

int cmd_walken(int argc, const char **argv, const char *prefix)
{
	trace_printf(_("cmd_walken incoming...\n"));
	return 0;
}</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<span class='synopsis'><code>trace_printf</code>()</span>, defined in <span class='synopsis'><code>trace.h</code></span>, differs from <span class='synopsis'><code>printf</code>()</span> in
that it can be turned on or off at runtime. For the purposes of this
tutorial, we will write <span class='synopsis'><code>walken</code></span> as though it is intended for use as
a "plumbing" command: that is, a command which is used primarily in
scripts, rather than interactively by humans (a "porcelain" command).
So we will send our debug output to <span class='synopsis'><code>trace_printf</code>()</span> instead.
When running, enable trace output by setting the environment variable <span class='synopsis'><code>GIT_TRACE</code></span>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Add usage text and <span class='synopsis'><code>-h</code></span> handling, like all subcommands should consistently do
(our test suite will notice and complain if you fail to do so).
We&#8217;ll need to include the <span class='synopsis'><code>parse-options.h</code></span> header.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>#include "parse-options.h"

...

int cmd_walken(int argc, const char **argv, const char *prefix)
{
	const char * const walken_usage[] = {
		N_("git walken"),
		NULL,
	};
	struct option options[] = {
		OPT_END()
	};

	argc = parse_options(argc, argv, prefix, options, walken_usage, 0);

	...
}</pre>
</div>
</div>
<div class="paragraph">
<p>Also add the relevant line in <span class='synopsis'><code>builtin.h</code></span> near <span class='synopsis'><code>cmd_whatchanged</code>()</span>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>int cmd_walken(int argc, const char **argv, const char *prefix);</pre>
</div>
</div>
<div class="paragraph">
<p>Include the command in <span class='synopsis'><code>git.c</code></span> in <span class='synopsis'><code>commands</code>[]</span> near the entry for <span class='synopsis'><code>whatchanged</code></span>,
maintaining alphabetical ordering:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>{ "walken", cmd_walken, RUN_SETUP },</pre>
</div>
</div>
<div class="paragraph">
<p>Add it to the <span class='synopsis'><code>Makefile</code></span> near the line for <span class='synopsis'><code>builtin/worktree.o</code></span>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>BUILTIN_OBJS += builtin/walken.o</pre>
</div>
</div>
<div class="paragraph">
<p>Build and test out your command, without forgetting to ensure the <span class='synopsis'><code>DEVELOPER</code></span>
flag is set, and with <span class='synopsis'><code>GIT_TRACE</code></span> enabled so the debug output can be seen:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ echo DEVELOPER=1 &gt;&gt;config.mak
$ make
$ GIT_TRACE=1 ./bin-wrappers/git walken</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
For a more exhaustive overview of the new command process, take a look at
<span class='synopsis'><code>Documentation/MyFirstContribution.adoc</code></span>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
A reference implementation can be found at
<a href="https://github.com/nasamuffin/git/tree/revwalk" class="bare">https://github.com/nasamuffin/git/tree/revwalk</a>.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_struct_rev_cmdline_info"><a class="anchor" href="#_struct_rev_cmdline_info"></a><span class='synopsis'><code>struct</code> <code>rev_cmdline_info</code></span></h3>
<div class="paragraph">
<p>The definition of <span class='synopsis'><code>struct</code> <code>rev_cmdline_info</code></span> can be found in <span class='synopsis'><code>revision.h</code></span>.</p>
</div>
<div class="paragraph">
<p>This struct is contained within the <span class='synopsis'><code>rev_info</code></span> struct and is used to reflect
parameters provided by the user over the CLI.</p>
</div>
<div class="paragraph">
<p><span class='synopsis'><code>nr</code></span> represents the number of <span class='synopsis'><code>rev_cmdline_entry</code></span> present in the array.</p>
</div>
<div class="paragraph">
<p><span class='synopsis'><code>alloc</code></span> is used by the <span class='synopsis'><code>ALLOC_GROW</code></span> macro. Check <span class='synopsis'><code>alloc.h</code></span> - this variable is
used to track the allocated size of the list.</p>
</div>
<div class="paragraph">
<p>Per entry, we find:</p>
</div>
<div class="paragraph">
<p><span class='synopsis'><code>item</code></span> is the object provided upon which to base the object walk. Items in Git
can be blobs, trees, commits, or tags. (See <span class='synopsis'><code>Documentation/gittutorial-2.adoc</code></span>.)</p>
</div>
<div class="paragraph">
<p><span class='synopsis'><code>name</code></span> is the object ID (OID) of the object - a hex string you may be familiar
with from using Git to organize your source in the past. Check the tutorial
mentioned above towards the top for a discussion of where the OID can come
from.</p>
</div>
<div class="paragraph">
<p><span class='synopsis'><code>whence</code></span> indicates some information about what to do with the parents of the
specified object. We&#8217;ll explore this flag more later on; take a look at
<span class='synopsis'><code>Documentation/revisions.adoc</code></span> to get an idea of what could set the <span class='synopsis'><code>whence</code></span>
value.</p>
</div>
<div class="paragraph">
<p><span class='synopsis'><code>flags</code></span> are used to hint the beginning of the revision walk and are the first
block under the <span class='synopsis'><code>#include</code><code>s</code> <code>in</code> <code>revision.h</code></span>. The most likely ones to be set in
the <span class='synopsis'><code>rev_cmdline_info</code></span> are <span class='synopsis'><code>UNINTERESTING</code></span> and <span class='synopsis'><code>BOTTOM</code></span>, but these same flags
can be used during the walk, as well.</p>
</div>
</div>
<div class="sect2">
<h3 id="_struct_rev_info"><a class="anchor" href="#_struct_rev_info"></a><span class='synopsis'><code>struct</code> <code>rev_info</code></span></h3>
<div class="paragraph">
<p>This one is quite a bit longer, and many fields are only used during the walk
by <span class='synopsis'><code>revision.c</code></span> - not configuration options. Most of the configurable flags in
<span class='synopsis'><code>struct</code> <code>rev_info</code></span> have a mirror in <span class='synopsis'><code>Documentation/rev-list-options.adoc</code></span>. It&#8217;s a
good idea to take some time and read through that document.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_basic_commit_walk"><a class="anchor" href="#_basic_commit_walk"></a>Basic Commit Walk</h2>
<div class="sectionbody">
<div class="paragraph">
<p>First, let&#8217;s see if we can replicate the output of <span class='synopsis'><code>git</code> <code>log</code> <code>--oneline</code></span>. We&#8217;ll
refer back to the implementation frequently to discover norms when performing
an object walk of our own.</p>
</div>
<div class="paragraph">
<p>To do so, we&#8217;ll first find all the commits, in order, which preceded the current
commit. We&#8217;ll extract the name and subject of the commit from each.</p>
</div>
<div class="paragraph">
<p>Ideally, we will also be able to find out which ones are currently at the tip of
various branches.</p>
</div>
<div class="sect2">
<h3 id="_setting_up_2"><a class="anchor" href="#_setting_up_2"></a>Setting Up</h3>
<div class="paragraph">
<p>Preparing for your object walk has some distinct stages.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Perform default setup for this mode, and others which may be invoked.</p>
</li>
<li>
<p>Check configuration files for relevant settings.</p>
</li>
<li>
<p>Set up the <span class='synopsis'><code>rev_info</code></span> struct.</p>
</li>
<li>
<p>Tweak the initialized <span class='synopsis'><code>rev_info</code></span> to suit the current walk.</p>
</li>
<li>
<p>Prepare the <span class='synopsis'><code>rev_info</code></span> for the walk.</p>
</li>
<li>
<p>Iterate over the objects, processing each one.</p>
</li>
</ol>
</div>
<div class="sect3">
<h4 id="_default_setups"><a class="anchor" href="#_default_setups"></a>Default Setups</h4>
<div class="paragraph">
<p>Before examining configuration files which may modify command behavior, set up
default state for switches or options your command may have. If your command
utilizes other Git components, ask them to set up their default states as well.
For instance, <span class='synopsis'><code>git</code> <code>log</code></span> takes advantage of <span class='synopsis'><code>grep</code></span> and <span class='synopsis'><code>diff</code></span> functionality, so
its <span class='synopsis'><code>init_log_defaults</code>()</span> sets its own state (<span class='synopsis'><code>decoration_style</code></span>) and asks
<span class='synopsis'><code>grep</code></span> and <span class='synopsis'><code>diff</code></span> to initialize themselves by calling each of their
initialization functions.</p>
</div>
</div>
<div class="sect3">
<h4 id="_configuring_from_gitconfig"><a class="anchor" href="#_configuring_from_gitconfig"></a>Configuring From <span class='synopsis'><code>.gitconfig</code></span></h4>
<div class="paragraph">
<p>Next, we should have a look at any relevant configuration settings (i.e.,
settings readable and settable from <span class='synopsis'><code>git</code> <code>config</code></span>). This is done by providing a
callback to <span class='synopsis'><code>git_config</code>()</span>; within that callback, you can also invoke methods
from other components you may need that need to intercept these options. Your
callback will be invoked once per each configuration value which Git knows about
(global, local, worktree, etc.).</p>
</div>
<div class="paragraph">
<p>Similarly to the default values, we don&#8217;t have anything to do here yet
ourselves; however, we should call <span class='synopsis'><code>git_default_config</code>()</span> if we aren&#8217;t calling
any other existing config callbacks.</p>
</div>
<div class="paragraph">
<p>Add a new function to <span class='synopsis'><code>builtin/walken.c</code></span>.
We&#8217;ll also need to include the <span class='synopsis'><code>config.h</code></span> header:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>#include "config.h"

...

static int git_walken_config(const char *var, const char *value,
			     const struct config_context *ctx, void *cb)
{
	/*
	 * For now, we don't have any custom configuration, so fall back to
	 * the default config.
	 */
	return git_default_config(var, value, ctx, cb);
}</pre>
</div>
</div>
<div class="paragraph">
<p>Make sure to invoke <span class='synopsis'><code>git_config</code>()</span> with it in your <span class='synopsis'><code>cmd_walken</code>()</span>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>int cmd_walken(int argc, const char **argv, const char *prefix)
{
	...

	git_config(git_walken_config, NULL);

	...
}</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_setting_up_rev_info"><a class="anchor" href="#_setting_up_rev_info"></a>Setting Up <span class='synopsis'><code>rev_info</code></span></h4>
<div class="paragraph">
<p>Now that we&#8217;ve gathered external configuration and options, it&#8217;s time to
initialize the <span class='synopsis'><code>rev_info</code></span> object which we will use to perform the walk. This is
typically done by calling <span class='synopsis'><code>repo_init_revisions</code>()</span> with the repository you intend
to target, as well as the <span class='synopsis'><code>prefix</code></span> argument of <span class='synopsis'><code>cmd_walken</code></span> and your <span class='synopsis'><code>rev_info</code></span>
struct.</p>
</div>
<div class="paragraph">
<p>Add the <span class='synopsis'><code>struct</code> <code>rev_info</code></span> and the <span class='synopsis'><code>repo_init_revisions</code>()</span> call.
We&#8217;ll also need to include the <span class='synopsis'><code>revision.h</code></span> header:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>#include "revision.h"

...

int cmd_walken(int argc, const char **argv, const char *prefix)
{
	/* This can go wherever you like in your declarations.*/
	struct rev_info rev;
	...

	/* This should go after the git_config() call. */
	repo_init_revisions(the_repository, &amp;rev, prefix);

	...
}</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_tweaking_rev_info_for_the_walk"><a class="anchor" href="#_tweaking_rev_info_for_the_walk"></a>Tweaking <span class='synopsis'><code>rev_info</code></span> For the Walk</h4>
<div class="paragraph">
<p>We&#8217;re getting close, but we&#8217;re still not quite ready to go. Now that <span class='synopsis'><code>rev</code></span> is
initialized, we can modify it to fit our needs. This is usually done within a
helper for clarity, so let&#8217;s add one:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>static void final_rev_info_setup(struct rev_info *rev)
{
	/*
	 * We want to mimic the appearance of `git log --oneline`, so let's
	 * force oneline format.
	 */
	get_commit_format("oneline", rev);

	/* Start our object walk at HEAD. */
	add_head_to_pending(rev);
}</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>Instead of using the shorthand <span class='synopsis'><code>add_head_to_pending</code>()</span>, you could do
something like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	struct setup_revision_opt opt;

	memset(&amp;opt, 0, sizeof(opt));
	opt.def = "HEAD";
	opt.revarg_opt = REVARG_COMMITTISH;
	setup_revisions(argc, argv, rev, &amp;opt);</pre>
</div>
</div>
<div class="paragraph">
<p>Using a <span class='synopsis'><code>setup_revision_opt</code></span> gives you finer control over your walk&#8217;s starting
point.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Then let&#8217;s invoke <span class='synopsis'><code>final_rev_info_setup</code>()</span> after the call to
<span class='synopsis'><code>repo_init_revisions</code>()</span>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>int cmd_walken(int argc, const char **argv, const char *prefix)
{
	...

	final_rev_info_setup(&amp;rev);

	...
}</pre>
</div>
</div>
<div class="paragraph">
<p>Later, we may wish to add more arguments to <span class='synopsis'><code>final_rev_info_setup</code>()</span>. But for
now, this is all we need.</p>
</div>
</div>
<div class="sect3">
<h4 id="_preparing_rev_info_for_the_walk"><a class="anchor" href="#_preparing_rev_info_for_the_walk"></a>Preparing <span class='synopsis'><code>rev_info</code></span> For the Walk</h4>
<div class="paragraph">
<p>Now that <span class='synopsis'><code>rev</code></span> is all initialized and configured, we&#8217;ve got one more setup step
before we get rolling. We can do this in a helper, which will both prepare the
<span class='synopsis'><code>rev_info</code></span> for the walk, and perform the walk itself. Let&#8217;s start the helper
with the call to <span class='synopsis'><code>prepare_revision_walk</code>()</span>, which can return an error without
dying on its own:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>static void walken_commit_walk(struct rev_info *rev)
{
	if (prepare_revision_walk(rev))
		die(_("revision walk setup failed"));
}</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<span class='synopsis'><code>die</code>()</span> prints to <span class='synopsis'><code>stderr</code></span> and exits the program. Since it will print to
<span class='synopsis'><code>stderr</code></span> it&#8217;s likely to be seen by a human, so we will localize it.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_performing_the_walk"><a class="anchor" href="#_performing_the_walk"></a>Performing the Walk!</h4>
<div class="paragraph">
<p>Finally! We are ready to begin the walk itself. Now we can see that <span class='synopsis'><code>rev_info</code></span>
can also be used as an iterator; we move to the next item in the walk by using
<span class='synopsis'><code>get_revision</code>()</span> repeatedly. Add the listed variable declarations at the top and
the walk loop below the <span class='synopsis'><code>prepare_revision_walk</code>()</span> call within your
<span class='synopsis'><code>walken_commit_walk</code>()</span>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>#include "pretty.h"

...

static void walken_commit_walk(struct rev_info *rev)
{
	struct commit *commit;
	struct strbuf prettybuf = STRBUF_INIT;

	...

	while ((commit = get_revision(rev))) {
		strbuf_reset(&amp;prettybuf);
		pp_commit_easy(CMIT_FMT_ONELINE, commit, &amp;prettybuf);
		puts(prettybuf.buf);
	}
	strbuf_release(&amp;prettybuf);
}</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<span class='synopsis'><code>puts</code>()</span> prints a <span class='synopsis'><code>char*</code></span> to <span class='synopsis'><code>stdout</code></span>. Since this is the part of the
command we expect to be machine-parsed, we&#8217;re sending it directly to stdout.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Give it a shot.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ make
$ ./bin-wrappers/git walken</pre>
</div>
</div>
<div class="paragraph">
<p>You should see all of the subject lines of all the commits in
your tree&#8217;s history, in order, ending with the initial commit, "Initial revision
of "git", the information manager from hell". Congratulations! You&#8217;ve written
your first revision walk. You can play with printing some additional fields
from each commit if you&#8217;re curious; have a look at the functions available in
<span class='synopsis'><code>commit.h</code></span>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_adding_a_filter"><a class="anchor" href="#_adding_a_filter"></a>Adding a Filter</h3>
<div class="paragraph">
<p>Next, let&#8217;s try to filter the commits we see based on their author. This is
equivalent to running <span class='synopsis'><code>git</code> <code>log</code> <code>--author=</code><em>&lt;pattern&gt;</em></span>. We can add a filter by
modifying <span class='synopsis'><code>rev_info.grep_filter</code></span>, which is a <span class='synopsis'><code>struct</code> <code>grep_opt</code></span>.</p>
</div>
<div class="paragraph">
<p>First some setup. Add <span class='synopsis'><code>grep_config</code>()</span> to <span class='synopsis'><code>git_walken_config</code>()</span>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>static int git_walken_config(const char *var, const char *value,
			     const struct config_context *ctx, void *cb)
{
	grep_config(var, value, ctx, cb);
	return git_default_config(var, value, ctx, cb);
}</pre>
</div>
</div>
<div class="paragraph">
<p>Next, we can modify the <span class='synopsis'><code>grep_filter</code></span>. This is done with convenience functions
found in <span class='synopsis'><code>grep.h</code></span>. For fun, we&#8217;re filtering to only commits from folks using a
<span class='synopsis'><code>gmail.com</code></span> email address - a not-very-precise guess at who may be working on
Git as a hobby. Since we&#8217;re checking the author, which is a specific line in the
header, we&#8217;ll use the <span class='synopsis'><code>append_header_grep_pattern</code>()</span> helper. We can use
the <span class='synopsis'><code>enum</code> <code>grep_header_field</code></span> to indicate which part of the commit header we want
to search.</p>
</div>
<div class="paragraph">
<p>In <span class='synopsis'><code>final_rev_info_setup</code>()</span>, add your filter line:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>static void final_rev_info_setup(int argc, const char **argv,
		const char *prefix, struct rev_info *rev)
{
	...

	append_header_grep_pattern(&amp;rev-&gt;grep_filter, GREP_HEADER_AUTHOR,
		"gmail");
	compile_grep_patterns(&amp;rev-&gt;grep_filter);

	...
}</pre>
</div>
</div>
<div class="paragraph">
<p><span class='synopsis'><code>append_header_grep_pattern</code>()</span> adds your new "gmail" pattern to <span class='synopsis'><code>rev_info</code></span>, but
it won&#8217;t work unless we compile it with <span class='synopsis'><code>compile_grep_patterns</code>()</span>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
If you are using <span class='synopsis'><code>setup_revisions</code>()</span> (for example, if you are passing a
<span class='synopsis'><code>setup_revision_opt</code></span> instead of using <span class='synopsis'><code>add_head_to_pending</code>()</span>), you don&#8217;t need
to call <span class='synopsis'><code>compile_grep_patterns</code>()</span> because <span class='synopsis'><code>setup_revisions</code>()</span> calls it for you.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
We could add the same filter via the <span class='synopsis'><code>append_grep_pattern</code>()</span> helper if we
wanted to, but <span class='synopsis'><code>append_header_grep_pattern</code>()</span> adds the <span class='synopsis'><code>enum</code> <code>grep_context</code></span> and
<span class='synopsis'><code>enum</code> <code>grep_pat_token</code></span> for us.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_changing_the_order"><a class="anchor" href="#_changing_the_order"></a>Changing the Order</h3>
<div class="paragraph">
<p>There are a few ways that we can change the order of the commits during a
revision walk. Firstly, we can use the <span class='synopsis'><code>enum</code> <code>rev_sort_order</code></span> to choose from some
typical orderings.</p>
</div>
<div class="paragraph">
<p><span class='synopsis'><code>topo_order</code></span> is the same as <span class='synopsis'><code>git</code> <code>log</code> <code>--topo-order</code></span>: we avoid showing a parent
before all of its children have been shown, and we avoid mixing commits which
are in different lines of history. (<span class='synopsis'><code>git</code> <code>help</code> <code>log</code></span>'s section on <span class='synopsis'><code>--topo-order</code></span>
has a very nice diagram to illustrate this.)</p>
</div>
<div class="paragraph">
<p>Let&#8217;s see what happens when we run with <span class='synopsis'><code>REV_SORT_BY_COMMIT_DATE</code></span> as opposed to
<span class='synopsis'><code>REV_SORT_BY_AUTHOR_DATE</code></span>. Add the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>static void final_rev_info_setup(int argc, const char **argv,
		const char *prefix, struct rev_info *rev)
{
	...

	rev-&gt;topo_order = 1;
	rev-&gt;sort_order = REV_SORT_BY_COMMIT_DATE;

	...
}</pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s output this into a file so we can easily diff it with the walk sorted by
author date.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ make
$ ./bin-wrappers/git walken &gt; commit-date.txt</pre>
</div>
</div>
<div class="paragraph">
<p>Then, let&#8217;s sort by author date and run it again.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>static void final_rev_info_setup(int argc, const char **argv,
		const char *prefix, struct rev_info *rev)
{
	...

	rev-&gt;topo_order = 1;
	rev-&gt;sort_order = REV_SORT_BY_AUTHOR_DATE;

	...
}</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>$ make
$ ./bin-wrappers/git walken &gt; author-date.txt</pre>
</div>
</div>
<div class="paragraph">
<p>Finally, compare the two. This is a little less helpful without object names or
dates, but hopefully we get the idea.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ diff -u commit-date.txt author-date.txt</pre>
</div>
</div>
<div class="paragraph">
<p>This display indicates that commits can be reordered after they&#8217;re written, for
example with <span class='synopsis'><code>git</code> <code>rebase</code></span>.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s try one more reordering of commits. <span class='synopsis'><code>rev_info</code></span> exposes a <span class='synopsis'><code>reverse</code></span> flag.
Set that flag somewhere inside of <span class='synopsis'><code>final_rev_info_setup</code>()</span>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>static void final_rev_info_setup(int argc, const char **argv, const char *prefix,
		struct rev_info *rev)
{
	...

	rev-&gt;reverse = 1;

	...
}</pre>
</div>
</div>
<div class="paragraph">
<p>Run your walk again and note the difference in order. (If you remove the grep
pattern, you should see the last commit this call gives you as your current
HEAD.)</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_basic_object_walk"><a class="anchor" href="#_basic_object_walk"></a>Basic Object Walk</h2>
<div class="sectionbody">
<div class="paragraph">
<p>So far we&#8217;ve been walking only commits. But Git has more types of objects than
that! Let&#8217;s see if we can walk <em>all</em> objects, and find out some information
about each one.</p>
</div>
<div class="paragraph">
<p>We can base our work on an example. <span class='synopsis'><code>git</code> <code>pack-objects</code></span> prepares all kinds of
objects for packing into a bitmap or packfile. The work we are interested in
resides in <span class='synopsis'><code>builtin/pack-objects.c:get_object_list</code>()</span>; examination of that
function shows that the all-object walk is being performed by
<span class='synopsis'><code>traverse_commit_list</code>()</span> or <span class='synopsis'><code>traverse_commit_list_filtered</code>()</span>. Those two
functions reside in <span class='synopsis'><code>list-objects.c</code></span>; examining the source shows that, despite
the name, these functions traverse all kinds of objects. Let&#8217;s have a look at
the arguments to <span class='synopsis'><code>traverse_commit_list</code>()</span>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><span class='synopsis'><code>struct</code> <code>rev_info</code> <code>*revs</code></span>: This is the <span class='synopsis'><code>rev_info</code></span> used for the walk. If
its <span class='synopsis'><code>filter</code></span> member is not <span class='synopsis'><code>NULL</code></span>, then <span class='synopsis'><code>filter</code></span> contains information for
how to filter the object list.</p>
</li>
<li>
<p><span class='synopsis'><code>show_commit_fn</code> <code>show_commit</code></span>: A callback which will be used to handle each
individual commit object.</p>
</li>
<li>
<p><span class='synopsis'><code>show_object_fn</code> <code>show_object</code></span>: A callback which will be used to handle each
non-commit object (so each blob, tree, or tag).</p>
</li>
<li>
<p><span class='synopsis'><code>void</code> <code>*show_data</code></span>: A context buffer which is passed in turn to <span class='synopsis'><code>show_commit</code></span>
and <span class='synopsis'><code>show_object</code></span>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In addition, <span class='synopsis'><code>traverse_commit_list_filtered</code>()</span> has an additional parameter:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><span class='synopsis'><code>struct</code> <code>oidset</code> <code>*omitted</code></span>: A linked-list of object IDs which the provided
filter caused to be omitted.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>It looks like these methods use callbacks we provide instead of needing us
to call it repeatedly ourselves. Cool! Let&#8217;s add the callbacks first.</p>
</div>
<div class="paragraph">
<p>For the sake of this tutorial, we&#8217;ll simply keep track of how many of each kind
of object we find. At file scope in <span class='synopsis'><code>builtin/walken.c</code></span> add the following
tracking variables:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>static int commit_count;
static int tag_count;
static int blob_count;
static int tree_count;</pre>
</div>
</div>
<div class="paragraph">
<p>Commits are handled by a different callback than other objects; let&#8217;s do that
one first:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>static void walken_show_commit(struct commit *cmt, void *buf)
{
	commit_count++;
}</pre>
</div>
</div>
<div class="paragraph">
<p>The <span class='synopsis'><code>cmt</code></span> argument is fairly self-explanatory. But it&#8217;s worth mentioning that
the <span class='synopsis'><code>buf</code></span> argument is actually the context buffer that we can provide to the
traversal calls - <span class='synopsis'><code>show_data</code></span>, which we mentioned a moment ago.</p>
</div>
<div class="paragraph">
<p>Since we have the <span class='synopsis'><code>struct</code> <code>commit</code></span> object, we can look at all the same parts that
we looked at in our earlier commit-only walk. For the sake of this tutorial,
though, we&#8217;ll just increment the commit counter and move on.</p>
</div>
<div class="paragraph">
<p>The callback for non-commits is a little different, as we&#8217;ll need to check
which kind of object we&#8217;re dealing with:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>static void walken_show_object(struct object *obj, const char *str, void *buf)
{
	switch (obj-&gt;type) {
	case OBJ_TREE:
		tree_count++;
		break;
	case OBJ_BLOB:
		blob_count++;
		break;
	case OBJ_TAG:
		tag_count++;
		break;
	case OBJ_COMMIT:
		BUG("unexpected commit object in walken_show_object\n");
	default:
		BUG("unexpected object type %s in walken_show_object\n",
			type_name(obj-&gt;type));
	}
}</pre>
</div>
</div>
<div class="paragraph">
<p>Again, <span class='synopsis'><code>obj</code></span> is fairly self-explanatory, and we can guess that <span class='synopsis'><code>buf</code></span> is the same
context pointer that <span class='synopsis'><code>walken_show_commit</code>()</span> receives: the <span class='synopsis'><code>show_data</code></span> argument
to <span class='synopsis'><code>traverse_commit_list</code>()</span> and <span class='synopsis'><code>traverse_commit_list_filtered</code>()</span>. Finally,
<span class='synopsis'><code>str</code></span> contains the name of the object, which ends up being something like
<span class='synopsis'><code>foo.txt</code></span> (blob), <span class='synopsis'><code>bar/baz</code></span> (tree), or <span class='synopsis'><code>v1.2.3</code></span> (tag).</p>
</div>
<div class="paragraph">
<p>To help assure us that we aren&#8217;t double-counting commits, we&#8217;ll include some
complaining if a commit object is routed through our non-commit callback; we&#8217;ll
also complain if we see an invalid object type. Since those two cases should be
unreachable, and would only change in the event of a semantic change to the Git
codebase, we complain by using <span class='synopsis'><code>BUG</code>()</span> - which is a signal to a developer that
the change they made caused unintended consequences, and the rest of the
codebase needs to be updated to understand that change. <span class='synopsis'><code>BUG</code>()</span> is not intended
to be seen by the public, so it is not localized.</p>
</div>
<div class="paragraph">
<p>Our main object walk implementation is substantially different from our commit
walk implementation, so let&#8217;s make a new function to perform the object walk. We
can perform setup which is applicable to all objects here, too, to keep separate
from setup which is applicable to commit-only walks.</p>
</div>
<div class="paragraph">
<p>We&#8217;ll start by enabling all types of objects in the <span class='synopsis'><code>struct</code> <code>rev_info</code></span>.  We&#8217;ll
also turn on <span class='synopsis'><code>tree_blobs_in_commit_order</code></span>, which means that we will walk a
commit&#8217;s tree and everything it points to immediately after we find each commit,
as opposed to waiting for the end and walking through all trees after the commit
history has been discovered. With the appropriate settings configured, we are
ready to call <span class='synopsis'><code>prepare_revision_walk</code>()</span>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>static void walken_object_walk(struct rev_info *rev)
{
	rev-&gt;tree_objects = 1;
	rev-&gt;blob_objects = 1;
	rev-&gt;tag_objects = 1;
	rev-&gt;tree_blobs_in_commit_order = 1;

	if (prepare_revision_walk(rev))
		die(_("revision walk setup failed"));

	commit_count = 0;
	tag_count = 0;
	blob_count = 0;
	tree_count = 0;</pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s start by calling just the unfiltered walk and reporting our counts.
Complete your implementation of <span class='synopsis'><code>walken_object_walk</code>()</span>.
We&#8217;ll also need to include the <span class='synopsis'><code>list-objects.h</code></span> header.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>#include "list-objects.h"

...

	traverse_commit_list(rev, walken_show_commit, walken_show_object, NULL);

	printf("commits %d\nblobs %d\ntags %d\ntrees %d\n", commit_count,
		blob_count, tag_count, tree_count);
}</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
This output is intended to be machine-parsed. Therefore, we are not
sending it to <span class='synopsis'><code>trace_printf</code>()</span>, and we are not localizing it - we need scripts
to be able to count on the formatting to be exactly the way it is shown here.
If we were intending this output to be read by humans, we would need to localize
it with <span class='synopsis'><code>_</code>()</span>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Finally, we&#8217;ll ask <span class='synopsis'><code>cmd_walken</code>()</span> to use the object walk instead. Discussing
command line options is out of scope for this tutorial, so we&#8217;ll just hardcode
a branch we can change at compile time. Where you call <span class='synopsis'><code>final_rev_info_setup</code>()</span>
and <span class='synopsis'><code>walken_commit_walk</code>()</span>, instead branch like so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	if (1) {
		add_head_to_pending(&amp;rev);
		walken_object_walk(&amp;rev);
	} else {
		final_rev_info_setup(argc, argv, prefix, &amp;rev);
		walken_commit_walk(&amp;rev);
	}</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
For simplicity, we&#8217;ve avoided all the filters and sorts we applied in
<span class='synopsis'><code>final_rev_info_setup</code>()</span> and simply added <span class='synopsis'><code>HEAD</code></span> to our pending queue. If you
want, you can certainly use the filters we added before by moving
<span class='synopsis'><code>final_rev_info_setup</code>()</span> out of the conditional and removing the call to
<span class='synopsis'><code>add_head_to_pending</code>()</span>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Now we can try to run our command! It should take noticeably longer than the
commit walk, but an examination of the output will give you an idea why. Your
output should look similar to this example, but with different counts:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Object walk completed. Found 55733 commits, 100274 blobs, 0 tags, and 104210 trees.</pre>
</div>
</div>
<div class="paragraph">
<p>This makes sense. We have more trees than commits because the Git project has
lots of subdirectories which can change, plus at least one tree per commit. We
have no tags because we started on a commit (<span class='synopsis'><code>HEAD</code></span>) and while tags can point to
commits, commits can&#8217;t point to tags.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
You will have different counts when you run this yourself! The number of
objects grows along with the Git project.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_adding_a_filter_2"><a class="anchor" href="#_adding_a_filter_2"></a>Adding a Filter</h3>
<div class="paragraph">
<p>There are a handful of filters that we can apply to the object walk laid out in
<span class='synopsis'><code>Documentation/rev-list-options.adoc</code></span>. These filters are typically useful for
operations such as creating packfiles or performing a partial clone. They are
defined in <span class='synopsis'><code>list-objects-filter-options.h</code></span>. For the purposes of this tutorial we
will use the "tree:1" filter, which causes the walk to omit all trees and blobs
which are not directly referenced by commits reachable from the commit in
<span class='synopsis'><code>pending</code></span> when the walk begins. (<span class='synopsis'><code>pending</code></span> is the list of objects which need to
be traversed during a walk; you can imagine a breadth-first tree traversal to
help understand. In our case, that means we omit trees and blobs not directly
referenced by <span class='synopsis'><code>HEAD</code></span> or <span class='synopsis'><code>HEAD</code></span>'s history, because we begin the walk with only
<span class='synopsis'><code>HEAD</code></span> in the <span class='synopsis'><code>pending</code></span> list.)</p>
</div>
<div class="paragraph">
<p>For now, we are not going to track the omitted objects, so we&#8217;ll replace those
parameters with <span class='synopsis'><code>NULL</code></span>. For the sake of simplicity, we&#8217;ll add a simple
build-time branch to use our filter or not. Preface the line calling
<span class='synopsis'><code>traverse_commit_list</code>()</span> with the following, which will remind us which kind of
walk we&#8217;ve just performed:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	if (0) {
		/* Unfiltered: */
		trace_printf(_("Unfiltered object walk.\n"));
	} else {
		trace_printf(
			_("Filtered object walk with filterspec 'tree:1'.\n"));

		parse_list_objects_filter(&amp;rev-&gt;filter, "tree:1");
	}
	traverse_commit_list(rev, walken_show_commit,
			     walken_show_object, NULL);</pre>
</div>
</div>
<div class="paragraph">
<p>The <span class='synopsis'><em>rev-&gt;filter</em></span> member is usually built directly from a command
line argument, so the module provides an easy way to build one from a string.
Even though we aren&#8217;t taking user input right now, we can still build one with
a hardcoded string using <span class='synopsis'><code>parse_list_objects_filter</code>()</span>.</p>
</div>
<div class="paragraph">
<p>With the filter spec "tree:1", we are expecting to see <em>only</em> the root tree for
each commit; therefore, the tree object count should be less than or equal to
the number of commits. (For an example of why that&#8217;s true: <span class='synopsis'><code>git</code> <code>commit</code> <code>--revert</code></span>
points to the same tree object as its grandparent.)</p>
</div>
</div>
<div class="sect2">
<h3 id="_counting_omitted_objects"><a class="anchor" href="#_counting_omitted_objects"></a>Counting Omitted Objects</h3>
<div class="paragraph">
<p>We also have the capability to enumerate all objects which were omitted by a
filter, like with <span class='synopsis'><code>git</code> <code>log</code> <code>--filter=</code><em>&lt;spec&gt;</em> <code>--filter-print-omitted</code></span>. To do this,
change <span class='synopsis'><code>traverse_commit_list</code>()</span> to <span class='synopsis'><code>traverse_commit_list_filtered</code>()</span>, which is
able to populate an <span class='synopsis'><code>omitted</code></span> list.  Asking for this list of filtered objects
may cause performance degradations, however, because in this case, despite
filtering objects, the possibly much larger set of all reachable objects must
be processed in order to populate that list.</p>
</div>
<div class="paragraph">
<p>First, add the <span class='synopsis'><code>struct</code> <code>oidset</code></span> and related items we will use to iterate it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>#include "oidset.h"

...

static void walken_object_walk(
	...

	struct oidset omitted;
	struct oidset_iter oit;
	struct object_id *oid = NULL;
	int omitted_count = 0;
	oidset_init(&amp;omitted, 0);

	...</pre>
</div>
</div>
<div class="paragraph">
<p>Replace the call to <span class='synopsis'><code>traverse_commit_list</code>()</span> with
<span class='synopsis'><code>traverse_commit_list_filtered</code>()</span> and pass a pointer to the <span class='synopsis'><code>omitted</code></span> oidset
defined and initialized above:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	...

		traverse_commit_list_filtered(rev,
			walken_show_commit, walken_show_object, NULL, &amp;omitted);

	...</pre>
</div>
</div>
<div class="paragraph">
<p>Then, after your traversal, the <span class='synopsis'><code>oidset</code></span> traversal is pretty straightforward.
Count all the objects within and modify the print statement:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	/* Count the omitted objects. */
	oidset_iter_init(&amp;omitted, &amp;oit);

	while ((oid = oidset_iter_next(&amp;oit)))
		omitted_count++;

	printf("commits %d\nblobs %d\ntags %d\ntrees %d\nomitted %d\n",
		commit_count, blob_count, tag_count, tree_count, omitted_count);</pre>
</div>
</div>
<div class="paragraph">
<p>By running your walk with and without the filter, you should find that the total
object count in each case is identical. You can also time each invocation of
the <span class='synopsis'><code>walken</code></span> subcommand, with and without <span class='synopsis'><code>omitted</code></span> being passed in, to confirm
to yourself the runtime impact of tracking all omitted objects.</p>
</div>
</div>
<div class="sect2">
<h3 id="_changing_the_order_2"><a class="anchor" href="#_changing_the_order_2"></a>Changing the Order</h3>
<div class="paragraph">
<p>Finally, let&#8217;s demonstrate that you can also reorder walks of all objects, not
just walks of commits. First, we&#8217;ll make our handlers chattier - modify
<span class='synopsis'><code>walken_show_commit</code>()</span> and <span class='synopsis'><code>walken_show_object</code>()</span> to print the object as they
go:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>#include "hex.h"

...

static void walken_show_commit(struct commit *cmt, void *buf)
{
	trace_printf("commit: %s\n", oid_to_hex(&amp;cmt-&gt;object.oid));
	commit_count++;
}

static void walken_show_object(struct object *obj, const char *str, void *buf)
{
	trace_printf("%s: %s\n", type_name(obj-&gt;type), oid_to_hex(&amp;obj-&gt;oid));

	...
}</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Since we will be examining this output directly as humans, we&#8217;ll use
<span class='synopsis'><code>trace_printf</code>()</span> here. Additionally, since this change introduces a significant
number of printed lines, using <span class='synopsis'><code>trace_printf</code>()</span> will allow us to easily silence
those lines without having to recompile.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>(Leave the counter increment logic in place.)</p>
</div>
<div class="paragraph">
<p>With only that change, run again (but save yourself some scrollback):</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ GIT_TRACE=1 ./bin-wrappers/git walken 2&gt;&amp;1 | head -n 10</pre>
</div>
</div>
<div class="paragraph">
<p>Take a look at the top commit with <span class='synopsis'><code>git</code> <code>show</code></span> and the object ID you printed; it
should be the same as the output of <span class='synopsis'><code>git</code> <code>show</code> <code>HEAD</code></span>.</p>
</div>
<div class="paragraph">
<p>Next, let&#8217;s change a setting on our <span class='synopsis'><code>struct</code> <code>rev_info</code></span> within
<span class='synopsis'><code>walken_object_walk</code>()</span>. Find where you&#8217;re changing the other settings on <span class='synopsis'><code>rev</code></span>,
such as <span class='synopsis'><em>rev-&gt;tree_objects</em></span> and <span class='synopsis'><em>rev-&gt;tree_blobs_in_commit_order</em></span>, and add the
<span class='synopsis'><code>reverse</code></span> setting at the bottom:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	...

	rev-&gt;tree_objects = 1;
	rev-&gt;blob_objects = 1;
	rev-&gt;tag_objects = 1;
	rev-&gt;tree_blobs_in_commit_order = 1;
	rev-&gt;reverse = 1;

	...</pre>
</div>
</div>
<div class="paragraph">
<p>Now, run again, but this time, let&#8217;s grab the last handful of objects instead
of the first handful:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ make
$ GIT_TRACE=1 ./bin-wrappers/git walken 2&gt;&amp;1 | tail -n 10</pre>
</div>
</div>
<div class="paragraph">
<p>The last commit object given should have the same OID as the one we saw at the
top before, and running <span class='synopsis'><code>git</code> <code>show</code> <em>&lt;oid&gt;</em></span> with that OID should give you again
the same results as <span class='synopsis'><code>git</code> <code>show</code> <code>HEAD</code></span>. Furthermore, if you run and examine the
first ten lines again (with <span class='synopsis'><code>head</code></span> instead of <span class='synopsis'><code>tail</code></span> like we did before applying
the <span class='synopsis'><code>reverse</code></span> setting), you should see that now the first commit printed is the
initial commit, <span class='synopsis'><code>e83c5163</code></span>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_wrapping_up"><a class="anchor" href="#_wrapping_up"></a>Wrapping Up</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Let&#8217;s review. In this tutorial, we:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Built a commit walk from the ground up</p>
</li>
<li>
<p>Enabled a grep filter for that commit walk</p>
</li>
<li>
<p>Changed the sort order of that filtered commit walk</p>
</li>
<li>
<p>Built an object walk (tags, commits, trees, and blobs) from the ground up</p>
</li>
<li>
<p>Learned how to add a filter-spec to an object walk</p>
</li>
<li>
<p>Changed the display order of the filtered object walk</p>
</li>
</ul>
</div>
</div>
</div>