---
### DO NOT EDIT! Generated by script/update-docs.rb

category: manual
section: documentation
subsection: manual
title: Git - git-log Documentation
docname: git-log
lang: zh_HANS-CN
aliases:
- "/docs/git-log/zh_HANS-CN/index.html"
---
<div class="sect1">
<h2 id="_名称"><a class="anchor" href="#_名称"></a>名称</h2>
<div class="sectionbody">
<div class="paragraph">
<p>git-log - 显示提交日志</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_概述"><a class="anchor" href="#_概述"></a>概述</h2>
<div class="sectionbody">
<div class="verseblock">
<pre class="content"><em>git log</em> [&lt;options&gt;] [&lt;revision-range&gt;] [[--] &lt;path&gt;&#8230;&#8203;]</pre>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_描述"><a class="anchor" href="#_描述"></a>描述</h2>
<div class="sectionbody">
<div class="paragraph">
<p>显示提交日志。</p>
</div>
<div class="paragraph">
<p>列出可以从给定的提交中通过 "父 "链接到达的提交，但不包括可以从前面有"^"的提交中到达的提交。 默认情况下，输出结果是按时间顺序倒置的。</p>
</div>
<div class="paragraph">
<p>你可以把它看成是一个集合操作。从命令行上给出的任何一个提交中可以到达的提交形成一个集合，然后从这个集合中减去任何一个前面带有'^'的提交。 剩下的提交内容就是命令的输出结果。 其他各种选项和路径参数也可以用来进一步限制结果。</p>
</div>
<div class="paragraph">
<p>因此，可以执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git log foo bar ^baz</pre>
</div>
</div>
<div class="paragraph">
<p>意思是 "列出所有可以从&#8217;foo&#8217;或&#8217;bar'，但不能从&#8217;baz&#8217;到达的提交"。</p>
</div>
<div class="paragraph">
<p>一个特殊的符号 "<em>&lt;提交 1&gt;</em>&#8230;&#8203;<em>&lt;提交 2&gt;</em>" 可以作为 "^<em>&lt;提交 1&gt;</em> <em>&lt;提交 2&gt;</em>" 的简称。例如，以下两种情况可以互换使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git log origin..HEAD
$ git log HEAD ^origin</pre>
</div>
</div>
<div class="paragraph">
<p>另一个特殊的符号是 "<em>&lt;提交 1&gt;</em>&#8230;&#8203;<em>&lt;提交 2&gt;</em>"，对合并很有用。 由此产生的提交集合是两个操作数之间的对称差。 以下两个命令是等价的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git log A B --not $(git merge-base --all A B)
$ git log A...B</pre>
</div>
</div>
<div class="paragraph">
<p>该命令采用适用于 <a href='{{< relurl "docs/git-rev-list/zh_HANS-CN" >}}'>git-rev-list[1]</a> 命令的选项来控制显示的内容和方式，以及适用于 <a href='{{< relurl "docs/git-diff/zh_HANS-CN" >}}'>git-diff[1]</a> 命令的选项来控制每次提交引入的更改的显示方式。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_选项"><a class="anchor" href="#_选项"></a>选项</h2>
<div class="sectionbody">
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-log---follow"> <a class="anchor" href="#git-log---follow"></a>--follow </dt>
<dd>
<p>继续列出文件的历史记录，包括重命名之后的情况（仅适用于单个文件）。</p>
</dd>
<dt class="hdlist1" id="git-log---no-decorate"> <a class="anchor" href="#git-log---no-decorate"></a>--no-decorate </dt>
<dt class="hdlist1" id="git-log---decorateshortfullautono"> <a class="anchor" href="#git-log---decorateshortfullautono"></a>--decorate[=short|full|auto|no] </dt>
<dd>
<p>打印显示的任何提交的引用名称。如果指定了 "short"，则不会打印引用名称的前缀 "refs/heads/"、"refs/tags/" 和 "refs/remotes/"。如果指定了 "full"，将打印完整的引用名称（包括前缀）。如果指定了 "auto"，则如果输出是发送到终端，则显示引用名称，就如同指定了"short"一样，否则不显示引用名称。选项 <code>--decorate</code> 是 <code>--decorate=short</code> 的简写。如果配置了 <code>log.decorate</code> 的配置值，默认为配置值，否则为 "auto"。</p>
</dd>
<dt class="hdlist1" id="git-log---decorate-refsltpatterngt"> <a class="anchor" href="#git-log---decorate-refsltpatterngt"></a>--decorate-refs=&lt;pattern&gt; </dt>
<dt class="hdlist1" id="git-log---decorate-refs-excludeltpatterngt"> <a class="anchor" href="#git-log---decorate-refs-excludeltpatterngt"></a>--decorate-refs-exclude=&lt;pattern&gt; </dt>
<dd>
<p>对于每个候选引用，在以下情况下不要将其用于装饰（decorate）：若它与`--decorate-refs-exclude`指定的任何模式匹配，或者若它不与`--decorate-refs`指定的任何模式匹配。配置选项`log.excludeDecoration`允许从装饰中排除引用，但是在`log.excludeDecoration`中的匹配项将被`--decorate-refs`模式中的显式指定所覆盖。</p>
<div class="paragraph">
<p>如果没有给出这些选项或配置设置中的任何一个，那么如果引用与 <code>HEAD</code> 、<code>refs/heads/</code>、<code>refs/remotes/</code> 、<code>refs/stash/</code> 或 <code>refs/tags/</code> 匹配，则使用引用作为装饰。</p>
</div>
</dd>
<dt class="hdlist1" id="git-log---clear-decorations"> <a class="anchor" href="#git-log---clear-decorations"></a>--clear-decorations </dt>
<dd>
<p>当指定了该选项时，它会清除所有先前的 <code>--decorate-refs</code> 或 <code>--decorate-refs-exclude</code> 选项，并放宽默认的装饰过滤器以包括所有引用。如果配置值 <code>log.initialDecorationSet</code> 设置为 <code>all</code>，则假定使用此选项。</p>
</dd>
<dt class="hdlist1" id="git-log---source"> <a class="anchor" href="#git-log---source"></a>--source </dt>
<dd>
<p>打印出通过命令行给定的引用名称，以便触及每个提交。</p>
</dd>
<dt class="hdlist1" id="git-log---no-mailmap"> <a class="anchor" href="#git-log---no-mailmap"></a>--[no-]mailmap </dt>
<dt class="hdlist1" id="git-log---no-use-mailmap"> <a class="anchor" href="#git-log---no-use-mailmap"></a>--[no-]use-mailmap </dt>
<dd>
<p>使用 mailmap 文件将作者和提交者的名称和电子邮件地址映射到规范的真实名称和电子邮件地址。请参阅 <a href='{{< relurl "docs/git-shortlog/zh_HANS-CN" >}}'>git-shortlog[1]</a>。</p>
</dd>
<dt class="hdlist1" id="git-log---full-diff"> <a class="anchor" href="#git-log---full-diff"></a>--full-diff </dt>
<dd>
<p>如果不使用此标志， <code>git log -p &lt;path&gt;...</code> 将显示与指定路径相关的提交，并显示关于相同指定路径的差异。使用此标志，将显示与指定路径相关的提交的完整差异；这意味着 "&lt;path&gt;&#8230;&#8203;" 将仅限定提交，并不限定这些提交的差异。</p>
<div class="paragraph">
<p>请注意，这会影响所有基于差异的输出类型。例如：由 <code>--stat</code> 等产生的输出。</p>
</div>
</dd>
<dt class="hdlist1" id="git-log---log-size"> <a class="anchor" href="#git-log---log-size"></a>--log-size </dt>
<dd>
<p>在每个提交的输出中包含一行 ``log size &lt;number&gt;"" ，其中 &lt;number&gt; 是该提交消息的字节长度。旨在通过允许工具预先分配空间，加快从 <code>git log</code> 输出中读取日志消息的工具的速度。</p>
</dd>
<dt class="hdlist1" id="git-log--Lltgtltgtltgt"> <a class="anchor" href="#git-log--Lltgtltgtltgt"></a>-L&lt;起始&gt;,&lt;结束&gt;:&lt;文件&gt; </dt>
<dt class="hdlist1" id="git-log--Lltgtltgt"> <a class="anchor" href="#git-log--Lltgtltgt"></a>-L :&lt;函数名称&gt;:&lt;文件&gt; </dt>
<dd>
<p>追踪由 <em>&lt;起始&gt;,&lt;结束&gt;</em> 给出的行的范围，或由函数名称重合词 <em>&lt;函数名称&gt;</em> 给出的行的演变，在 <em>&lt;文件&gt;'中 。你不能给出任何路径规范限制条件。 目前这只限于从一个修订版开始的行走，也就是说，你只能给出零或一个正的修订版参数，而且 '&lt;起始&gt;</em> 和 <em>&lt;结束&gt;</em>（或 <em>&lt;函数名称&gt;</em>）必须存在于起始修订版中。 你可以多次指定这个选项。包含 <code>--patch</code> 选项。 补丁输出可以用 <code>--no-patch</code> 来抑制，但其他差异格式（即 <code>--raw</code> 、 <code>--numstat</code> 、 <code>--shortstat</code> 、 <code>--dirstat</code> 、 <code>--summary</code> 、 <code>--name-only</code> 、 <code>--name-status</code> 、 <code>--check</code>）目前没有实现。</p>
<div class="paragraph">
<p><em>&lt;开始&gt;</em> 和 <em>&lt;结束&gt;</em> 可以采取这些形式之一：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>数目</p>
<div class="paragraph">
<p>如果'&lt;开始&gt;'或'&lt;结束&gt;'是一个数字，它指定了一个绝对行数（行数从1开始计算）。</p>
</div>
</li>
<li>
<p><code>/正则表达式/</code></p>
<div class="paragraph">
<p>这种形式将使用与给定的 POSIX 正则表达式匹配的第一行。如果 <em>&lt;start&gt;</em> 是一个重词，它将从前一个 <code>-L</code> 范围的末尾开始搜索，如果有的话，则从文件的开始。 如果 <em>&lt;start&gt;</em> 是 <code>^/regex/</code>，它将从文件的开始搜索。 如果 <em>&lt;end&gt;</em> 是一个正则表达式，它将从 <em>&lt;start&gt;</em> 所给的行开始搜索。</p>
</div>
</li>
<li>
<p>+offset或-offset</p>
<div class="paragraph">
<p>这只对'&lt;end&gt;'有效，将指定'&lt;start&gt;'所给的行前或行后的数量。</p>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果 <code>:&lt;funcname&gt;</code> 代替了 <em>&lt;start&gt;</em> 和 <em>&lt;end&gt;</em> ，它是一个正则表达式，表示从第一个匹配 <em>&lt;funcname&gt;</em> 的 funcname 行开始，直到下一个 funcname 行的范围。<code>:&lt;funcname&gt;</code> 从上一个 <code>-L</code> 范围的末尾开始搜索，如果有的话，则从文件的开始搜索。<code>^:&lt;funcname&gt;`从文件的开始搜索。函数名的确定方式与 `git diff</code> 确定补丁组头的方式相同（见 <a href='{{< relurl "docs/gitattributes/zh_HANS-CN" >}}'>gitattributes[5]</a> 中的&#8217;定义自定义组头'）。</p>
</div>
</dd>
</dl>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-log-ltrevision-rangegt"> <a class="anchor" href="#git-log-ltrevision-rangegt"></a>&lt;revision-range&gt; </dt>
<dd>
<p>仅显示指定修订范围内的提交。当没有指定 &lt;revision-range&gt; 时，默认为 <code>HEAD</code>（即导致当前提交的整个历史记录）。<code>origin..HEAD</code> 指定从当前提交（即 <code>HEAD</code> ）可达的所有提交，但不包括从 <code>origin</code> 可达的提交。有关拼写 &lt;revision-range&gt; 的完整列表，请参阅 <a href='{{< relurl "docs/gitrevisions/zh_HANS-CN" >}}'>gitrevisions[7]</a> 的 "Specifying Ranges" 部分。</p>
</dd>
<dt class="hdlist1" id="git-log---ltpathgt82308203"> <a class="anchor" href="#git-log---ltpathgt82308203"></a>[--] &lt;path&gt;&#8230;&#8203; </dt>
<dd>
<p>只显示那些足以解释符合指定路径的文件是如何形成的提交。 有关细节和其他简化模式，请参见下面的&#8217;历史简化'。</p>
<div class="paragraph">
<p>当出现混淆时，路径可能需要以`--`为前缀，以便将其与选项或修订范围分开。</p>
</div>
</dd>
</dl>
</div>
<div class="sect2">
<h3 id="_承诺限制"><a class="anchor" href="#_承诺限制"></a>承诺限制</h3>
<div class="paragraph">
<p>除了使用描述中解释的特殊符号指定应列出的提交范围，还可以应用额外的提交限制。</p>
</div>
<div class="paragraph">
<p>使用更多的选项通常会进一步限制输出（例如，<code>--since=&lt;date1&gt;`限制在比</code>&lt;date1&gt;<code>新的提交，与</code>--grep=&lt;pattern&gt;<code>一起使用会进一步限制在日志信息中有一行符合</code>&lt;pattern&gt;`的提交），除非另有说明。</p>
</div>
<div class="paragraph">
<p>请注意，这些都是在提交排序和格式化选项之前应用的，如 <code>--reverse</code>。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-log--ltgt"> <a class="anchor" href="#git-log--ltgt"></a>-&lt;数&gt; </dt>
<dt class="hdlist1" id="git-log--nltgt"> <a class="anchor" href="#git-log--nltgt"></a>-n &lt;数量&gt; </dt>
<dt class="hdlist1" id="git-log---max-countltgt"> <a class="anchor" href="#git-log---max-countltgt"></a>--max-count=&lt;数量&gt; </dt>
<dd>
<p>限制输出的提交数量。</p>
</dd>
<dt class="hdlist1" id="git-log---skipltgt"> <a class="anchor" href="#git-log---skipltgt"></a>--skip=&lt;数量&gt; </dt>
<dd>
<p>在开始显示提交输出之前，跳过&#8217;数&#8217;的提交。</p>
</dd>
<dt class="hdlist1" id="git-log---sinceltgt"> <a class="anchor" href="#git-log---sinceltgt"></a>--since=&lt;日期&gt; </dt>
<dt class="hdlist1" id="git-log---afterltgt"> <a class="anchor" href="#git-log---afterltgt"></a>--after=&lt;日期&gt; </dt>
<dd>
<p>显示比某一特定日期更近的提交。</p>
</dd>
<dt class="hdlist1" id="git-log---since-as-filterltgt"> <a class="anchor" href="#git-log---since-as-filterltgt"></a>--since-as-filter=&lt;日期&gt; </dt>
<dd>
<p>显示所有比指定日期更近的提交。这将访问该范围内的所有提交，而不是停在第一个比指定日期更早的提交。</p>
</dd>
<dt class="hdlist1" id="git-log---untilltgt"> <a class="anchor" href="#git-log---untilltgt"></a>--until=&lt;日期&gt; </dt>
<dt class="hdlist1" id="git-log---beforeltgt"> <a class="anchor" href="#git-log---beforeltgt"></a>--before=&lt;日期&gt; </dt>
<dd>
<p>显示超过特定日期的提交。</p>
</dd>
<dt class="hdlist1" id="git-log---authorltgt"> <a class="anchor" href="#git-log---authorltgt"></a>--author=&lt;模式&gt; </dt>
<dt class="hdlist1" id="git-log---committerltgt"> <a class="anchor" href="#git-log---committerltgt"></a>--committer=&lt;模式&gt; </dt>
<dd>
<p>将提交文件的输出限制在作者/提交人标题行符合指定模式（正则表达式）的文件。 如果有多个`--author=&lt;pattern&gt;<code>，则会选择作者符合任何一个给定模式的提交（对于多个</code>--committer=&lt;pattern&gt;`也是如此）。</p>
</dd>
<dt class="hdlist1" id="git-log---grep-reflogltgt"> <a class="anchor" href="#git-log---grep-reflogltgt"></a>--grep-reflog=&lt;模式&gt; </dt>
<dd>
<p>将提交文件的输出限制在有符合指定模式（正则表达式）的reflog条目的提交文件。如果有多个 <code>--grep-reflog</code>，则会选择那些 reflog 信息符合任何指定模式的提交。 除非使用了`--walk-reflogs`，否则使用此选项是错误的。</p>
</dd>
<dt class="hdlist1" id="git-log---grepltgt"> <a class="anchor" href="#git-log---grepltgt"></a>--grep=&lt;模式&gt; </dt>
<dd>
<p>将提交结果限制在日志信息与指定模式（正则表达式）相匹配的提交。 如果有多个 <code>--grep=&lt;模式&gt;</code>，则会选择那些日志信息与任何指定模式相匹配的提交（但见 <code>--all-match</code>）。</p>
<div class="paragraph">
<p>当 <code>--notes</code> 生效时，笔记中的信息被匹配，就像它是日志信息的一部分。</p>
</div>
</dd>
<dt class="hdlist1" id="git-log---all-match"> <a class="anchor" href="#git-log---all-match"></a>--all-match </dt>
<dd>
<p>将输出的提交限制在符合所有给定`--grep`的提交，而不是至少符合一个的提交。</p>
</dd>
<dt class="hdlist1" id="git-log---invert-grep"> <a class="anchor" href="#git-log---invert-grep"></a>--invert-grep </dt>
<dd>
<p>限定输出的提交信息与 `--grep=&lt;模式&gt;`指定的模式不匹配。</p>
</dd>
<dt class="hdlist1" id="git-log--i"> <a class="anchor" href="#git-log--i"></a>-i </dt>
<dt class="hdlist1" id="git-log---regexp-ignore-case"> <a class="anchor" href="#git-log---regexp-ignore-case"></a>--regexp-ignore-case </dt>
<dd>
<p>匹配正则表达式的限制模式，不考虑字母大小写。</p>
</dd>
<dt class="hdlist1" id="git-log---basic-regexp"> <a class="anchor" href="#git-log---basic-regexp"></a>--basic-regexp </dt>
<dd>
<p>将限制性模式视为基本的正则表达式；这是默认的。</p>
</dd>
<dt class="hdlist1" id="git-log--E"> <a class="anchor" href="#git-log--E"></a>-E </dt>
<dt class="hdlist1" id="git-log---extended-regexp"> <a class="anchor" href="#git-log---extended-regexp"></a>--extended-regexp </dt>
<dd>
<p>将限制性模式视为扩展的正则表达式，而不是默认的基本正则表达式。</p>
</dd>
<dt class="hdlist1" id="git-log--F"> <a class="anchor" href="#git-log--F"></a>-F </dt>
<dt class="hdlist1" id="git-log---fixed-strings"> <a class="anchor" href="#git-log---fixed-strings"></a>--fixed-strings </dt>
<dd>
<p>将限制性模式视为固定字符串（不要将模式解释为正则表达式）。</p>
</dd>
<dt class="hdlist1" id="git-log--P"> <a class="anchor" href="#git-log--P"></a>-P </dt>
<dt class="hdlist1" id="git-log---perl-regexp"> <a class="anchor" href="#git-log---perl-regexp"></a>--perl-regexp </dt>
<dd>
<p>将限制性模式视为与Perl兼容的正则表达式。</p>
<div class="paragraph">
<p>对这些类型的正则表达式的支持是一个可选的编译时依赖。如果Git在编译时没有对它们的支持，提供这个选项将导致它死亡。</p>
</div>
</dd>
<dt class="hdlist1" id="git-log---remove-empty"> <a class="anchor" href="#git-log---remove-empty"></a>--remove-empty </dt>
<dd>
<p>当一个给定的路径从树上消失时停止。</p>
</dd>
<dt class="hdlist1" id="git-log---merges"> <a class="anchor" href="#git-log---merges"></a>--merges </dt>
<dd>
<p>只打印合并后的提交。这与`--min-parents=2`完全相同。</p>
</dd>
<dt class="hdlist1" id="git-log---no-merges"> <a class="anchor" href="#git-log---no-merges"></a>--no-merges </dt>
<dd>
<p>不打印有一个以上父级的提交。这与`--max-parents=1`完全相同。</p>
</dd>
<dt class="hdlist1" id="git-log---min-parentsltgt"> <a class="anchor" href="#git-log---min-parentsltgt"></a>--min-parents=&lt;数量&gt; </dt>
<dt class="hdlist1" id="git-log---max-parentsltgt"> <a class="anchor" href="#git-log---max-parentsltgt"></a>--max-parents=&lt;数量&gt; </dt>
<dt class="hdlist1" id="git-log---no-min-parents"> <a class="anchor" href="#git-log---no-min-parents"></a>--no-min-parents </dt>
<dt class="hdlist1" id="git-log---no-max-parents"> <a class="anchor" href="#git-log---no-max-parents"></a>--no-max-parents </dt>
<dd>
<p>只显示至少（或最多）有那么多父提交的提交。特别是，<code>--max-parents=1`等同于</code>--no-merges`，<code>--min-parents=2`等同于</code>--merges`。 <code>--max-parents=0`给出所有根提交，</code>--min-parents=3`给出所有章鱼合并。</p>
<div class="paragraph">
<p><code>--no-min-parents</code> 和 <code>--no-max-parents</code> 会再次重置这些限制（为无限制）。 等价形式是 <code>--min-parents=0</code>（任何提交都有 0 个或更多父代）和 <code>--max-parents=-1</code>（负数表示无上限）。</p>
</div>
</dd>
<dt class="hdlist1" id="git-log---first-parent"> <a class="anchor" href="#git-log---first-parent"></a>--first-parent </dt>
<dd>
<p>查找要包含的提交时，在看到合并提交时只跟随第一个父提交。 在查看某个特性分支的演变时，该选项可以提供更好的概览，因为合并到特性分支往往只是为了不时地适应上游的更新，而该选项可以让你忽略由合并带来的历史中的单个提交。</p>
<div class="paragraph">
<p>这个选项也改变了合并提交的默认差异格式为 <code>first-parent</code>，详见 <code>--diff-merges=first-parent</code>。</p>
</div>
</dd>
<dt class="hdlist1" id="git-log---exclude-first-parent-only"> <a class="anchor" href="#git-log---exclude-first-parent-only"></a>--exclude-first-parent-only </dt>
<dd>
<p>在寻找要排除的提交（用'^'）时，在看到合并提交时只跟随第一个父提交。 考虑到任意的合并都可以成为有效的主题分支变化，这可以用来查找主题分支中从它与远程分支的分歧点开始的变化集合。</p>
</dd>
<dt class="hdlist1" id="git-log---not"> <a class="anchor" href="#git-log---not"></a>--not </dt>
<dd>
<p>反转 <em>^</em> 前缀（或无前缀）对后面所有版本说明符的意义，直到下一个 <code>--not</code>。 在 --stdin 之前的命令行中使用时，通过标准输入流传递的修订版本不会受其影响。反之，通过标准输入传递时，命令行上传递的修订版本也不会受其影响。</p>
</dd>
<dt class="hdlist1" id="git-log---all"> <a class="anchor" href="#git-log---all"></a>--all </dt>
<dd>
<p>假设`refs/&#8216;中的所有参考文献，连同`HEAD`一起，在命令行中被列为&#8217;&lt;commit&gt;'。</p>
</dd>
<dt class="hdlist1" id="git-log---branchesltgt"> <a class="anchor" href="#git-log---branchesltgt"></a>--branches[=&lt;模式&gt;] </dt>
<dd>
<p>假设`refs/heads`中的所有 refs 在命令行中被列为 <em>&lt;commit&gt;</em>。如果给出了'&lt;pattern&gt;'，将分支限制在与给定的shell glob相匹配的分支。如果pattern缺少'?<em>、</em>*'或'[<em>，则末尾的</em>/*'是暗示的。</p>
</dd>
<dt class="hdlist1" id="git-log---tagsltgt"> <a class="anchor" href="#git-log---tagsltgt"></a>--tags[=&lt;模式&gt;] </dt>
<dd>
<p>假设`refs/tags`中的所有参考文献在命令行中被列为'&lt;commit&gt;'。如果给出了'&lt;pattern&gt;'，将标签限制在与给定的shell glob相匹配的标签。如果pattern缺少'?<em>、</em>*'或'[<em>，则暗示最后的</em>/*'。</p>
</dd>
<dt class="hdlist1" id="git-log---remotesltgt"> <a class="anchor" href="#git-log---remotesltgt"></a>--remotes[=&lt;模式&gt;] </dt>
<dd>
<p>假设`refs/remotes`中的所有 refs 在命令行中被列为 <em>&lt;commit&gt;</em>。如果给出了'&lt;pattern&gt;'，将远程跟踪分支限制在与给定的shell glob相匹配的分支。 如果pattern缺少'?<em>、</em>*'或'[<em>，则末尾的</em>/*'是暗示的。</p>
</dd>
<dt class="hdlist1" id="git-log---globltgt"> <a class="anchor" href="#git-log---globltgt"></a>--glob=&lt;通配符模式&gt; </dt>
<dd>
<p>假设所有与shell glob <em>&lt;glob-pattern&gt;相匹配的refs在命令行中被列为</em>&lt;commit&gt;'。前面的&#8217;refs/<em>，如果缺少的话会自动预加。如果模式中缺少</em>?<em>、</em>*'或'[<em>，则在结尾处隐含</em>/*'。</p>
</dd>
<dt class="hdlist1" id="git-log---excludeltgt"> <a class="anchor" href="#git-log---excludeltgt"></a>--exclude=&lt;通配符模式&gt; </dt>
<dd>
<p>不包括匹配"&lt;glob-pattern&gt;"的参考文献，否则下一个`--all`、<code>--branches</code>、<code>--tags</code>、<code>--remotes`或</code>--glob`会考虑这些参考文献。重复这个选项可以累积排除模式，直到下一个`----all`、<code>---branches</code>、<code>---tags</code>、<code>---remotes`或</code>---glob`选项（其他选项或参数不清除累积模式）。</p>
<div class="paragraph">
<p>当应用于 <code>--branches</code>、 <code>--tags</code> 或 <code>--remotes</code> 时，所给出的模式不应以 <code>refs/heads</code>、<code>refs/tags</code> 或 <code>refs/remotes</code> 开头；当应用于 <code>--glob</code> 或 <code>--all</code> 选项时，必须以 <code>refs/</code> 开头。如果要使用尾部的 <em>/*</em>，则必须明确给出。</p>
</div>
</dd>
<dt class="hdlist1" id="git-log---exclude-hiddenfetchreceiveuploadpack"> <a class="anchor" href="#git-log---exclude-hiddenfetchreceiveuploadpack"></a>--exclude-hidden=[fetch|receive|uploadpack] </dt>
<dd>
<p>通过查阅相应的 <code>fetch.hideRefs</code> 、<code>receive.hideRefs</code> 或 <code>uploadpack.hideRefs</code> 配置和 <code>transfer.hideRefs</code> 配置（参见 <a href='{{< relurl "docs/git-config/zh_HANS-CN" >}}'>git-config[1]</a>），不要包含会被 <code>git-fetch</code> 、<code>git-receive-pack</code> 或 <code>git-upload-pack</code> 隐藏的引用。该选项会影响下一个伪引用选项 <code>--all</code> 或 <code>--glob</code>，并在处理后清除。</p>
</dd>
<dt class="hdlist1" id="git-log---reflog"> <a class="anchor" href="#git-log---reflog"></a>--reflog </dt>
<dd>
<p>假设reflogs提到的所有对象都在命令行中被列为`&lt;commit&gt;`。</p>
</dd>
<dt class="hdlist1" id="git-log---alternate-refs"> <a class="anchor" href="#git-log---alternate-refs"></a>--alternate-refs </dt>
<dd>
<p>假设所有提到的作为备用仓库的参考提示的对象都列在命令行上。备用资源库是任何资源库，其对象目录在`objects/info/alternates`中指定。 包含的对象集可以通过`core.alternateRefsCommand`等修改。见<a href='{{< relurl "docs/git-config/zh_HANS-CN" >}}'>git-config[1]</a>。</p>
</dd>
<dt class="hdlist1" id="git-log---single-worktree"> <a class="anchor" href="#git-log---single-worktree"></a>--single-worktree </dt>
<dd>
<p>默认情况下，当有多个工作树时，所有工作树都会被以下选项检查（见<a href='{{< relurl "docs/git-worktree/zh_HANS-CN" >}}'>git-worktree[1]</a>）：<code>--all</code>，<code>--reflog`和</code>--indexed-objects`。 这个选项强制它们只检查当前的工作树。</p>
</dd>
<dt class="hdlist1" id="git-log---ignore-missing"> <a class="anchor" href="#git-log---ignore-missing"></a>--ignore-missing </dt>
<dd>
<p>在看到输入中无效的对象名称时，假装没有给出坏的输入。</p>
</dd>
<dt class="hdlist1" id="git-log---bisect"> <a class="anchor" href="#git-log---bisect"></a>--bisect </dt>
<dd>
<p>假设坏的二分法参考文献`refs/bisect/bad`被列出，并且在命令行中假设它后面是`--not`和好的二分法参考文献`refs/bisect/good-*`。</p>
</dd>
<dt class="hdlist1" id="git-log---stdin"> <a class="anchor" href="#git-log---stdin"></a>--stdin </dt>
<dd>
<p>除从命令行获取参数外，还可从标准输入读取参数。它接受提交和伪选项，如 <code>--all</code> 和 <code>--glob=</code>。当看到 <code>--</code> 分隔符时，下面的输入将被视为路径并用于限制结果。通过标准输入读取的 <code>--not</code> 等标志只适用于以相同方式传递的参数，不会影响后续的命令行参数。</p>
</dd>
<dt class="hdlist1" id="git-log---cherry-mark"> <a class="anchor" href="#git-log---cherry-mark"></a>--cherry-mark </dt>
<dd>
<p>就像`--cherry-pick`（见下文），但用`=<code>标记同等的提交，而不是省略，用</code>+`标记不同等的提交。</p>
</dd>
<dt class="hdlist1" id="git-log---cherry-pick"> <a class="anchor" href="#git-log---cherry-pick"></a>--cherry-pick </dt>
<dd>
<p>当提交的集合有对称差异时，省略任何与 "另一边 "的另一个提交相同的提交。</p>
<div class="paragraph">
<p>例如，如果你有两个分支，<code>A</code> 和 <code>B</code>，通常的方法是用`--左&#8212;&#8203;右`列出其中一边的所有提交（见下面关于`--left-right`选项的描述）。然而，它显示的是从另一个分支中偷梁换柱的提交（例如，<em>'3rd on b</em>' 可能是从分支 A 中偷梁换柱的）。有了这个选项，这样的提交对将从输出中排除。</p>
</div>
</dd>
<dt class="hdlist1" id="git-log---left-only"> <a class="anchor" href="#git-log---left-only"></a>--left-only </dt>
<dt class="hdlist1" id="git-log---right-only"> <a class="anchor" href="#git-log---right-only"></a>--right-only </dt>
<dd>
<p>只列出对称性差异各自一侧的提交，即只列出那些通过 <code>--left-right</code> 标记的 <code>&lt;</code> 或 <code>&gt;</code>。</p>
<div class="paragraph">
<p>例如，<code>--cherry-pick --right-only A...B`省略了`B`中那些在`A`中的提交或与`A`中的提交相等的补丁。换句话说，它列出了 "git cherry A B "的 "+"的提交。 更准确地说，</code>--cherry-pick --right-only --no-merges`可以得到准确的列表。</p>
</div>
</dd>
<dt class="hdlist1" id="git-log---cherry"> <a class="anchor" href="#git-log---cherry"></a>--cherry </dt>
<dd>
<p><code>--right-only --cherry-mark --no-merges`的同义词；有助于将输出限制在我们这边的提交，并标记那些已经应用到分叉历史的另一边的提交，`git log --cherry upstream...mybranch</code>，类似于`git cherry upstream mybranch`。</p>
</dd>
<dt class="hdlist1" id="git-log--g"> <a class="anchor" href="#git-log--g"></a>-g </dt>
<dt class="hdlist1" id="git-log---walk-reflogs"> <a class="anchor" href="#git-log---walk-reflogs"></a>--walk-reflogs </dt>
<dd>
<p>不走提交祖先链，而走从最近的提交到更早的提交的reflog条目。 使用这个选项时，你不能指定要排除的提交（也就是说，不能使用'^commit'、'commit1&#8230;&#8203;commit2&#8217;和&#8217;commit1/&#8230;&#8203;commit2&#8217;的符号）。</p>
<div class="paragraph">
<p>With <code>--pretty</code> format other than <code>oneline</code> and <code>reference</code> (for obvious reasons), this causes the output to have two extra lines of information taken from the reflog. The reflog designator in the output may be shown as <code>ref@{&lt;Nth&gt;}</code> (where <em>&lt;Nth&gt;</em> is the reverse-chronological index in the reflog) or as <code>ref@{&lt;timestamp&gt;}</code> (with the <em>&lt;timestamp&gt;</em> for that entry), depending on a few rules:</p>
</div>
<div class="openblock">
<div class="content">
<div class="olist arabic">
<ol class="arabic">
<li>
<p>If the starting point is specified as <code>ref@{&lt;Nth&gt;}</code>, show the index format.</p>
</li>
<li>
<p>如果起点被指定为`ref@{now}`，显示时间戳格式。</p>
</li>
<li>
<p>如果两者都没有使用，但在命令行中给出了`--date`，则按照`--date`所要求的格式显示时间戳。</p>
</li>
<li>
<p>否则，显示索引格式。</p>
</li>
</ol>
</div>
</div>
</div>
<div class="paragraph">
<p>在`--pretty=oneline`下，提交信息的前缀是同一行中的这些信息。 这个选项不能与 `--reverse`结合使用。 参见 <a href='{{< relurl "docs/git-reflog/zh_HANS-CN" >}}'>git-reflog[1]</a>。</p>
</div>
<div class="paragraph">
<p>在`--pretty=reference`下，这些信息将完全不显示。</p>
</div>
</dd>
<dt class="hdlist1" id="git-log---merge"> <a class="anchor" href="#git-log---merge"></a>--merge </dt>
<dd>
<p>显示在范围 <code>HEAD...&lt;其他&gt;</code> 中触及冲突路径的提交，其中 <code>&lt;其他&gt;</code> 是 <code>MERGE_HEAD</code>、<code>CHERRY_PICK_HEAD</code>、<code>REVERT_HEAD</code> 或 <code>REBASE_HEAD</code> 中第一个存在的伪引用。仅在索引中有未合并条目时有效。这个选项可以在解决三向合并中的冲突时用来显示相关的提交。</p>
</dd>
<dt class="hdlist1" id="git-log---boundary"> <a class="anchor" href="#git-log---boundary"></a>--boundary </dt>
<dd>
<p>输出排除的边界提交。边界提交的前缀是"-"。</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_简化历史"><a class="anchor" href="#_简化历史"></a>简化历史</h3>
<div class="paragraph">
<p>有时你只对历史的一部分感兴趣，例如修改某个&lt;路径&gt;的提交。但 "历史简化 "有两部分，一部分是选择提交，另一部分是如何做，因为有各种策略来简化历史。</p>
</div>
<div class="paragraph">
<p>以下选项选择要显示的提交：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-log-ltpathsgt"> <a class="anchor" href="#git-log-ltpathsgt"></a>&lt;paths&gt; </dt>
<dd>
<p>修改给定&lt;路径&gt;的提交会被选中。</p>
</dd>
<dt class="hdlist1" id="git-log---simplify-by-decoration"> <a class="anchor" href="#git-log---simplify-by-decoration"></a>--simplify-by-decoration </dt>
<dd>
<p>被某个分支或标签引用的提交被选中。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>请注意，可以显示额外的提交，以提供一个有意义的历史。</p>
</div>
<div class="paragraph">
<p>以下选项会影响简化的执行方式：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-log-"> <a class="anchor" href="#git-log-"></a>默认模式 </dt>
<dd>
<p>将历史简化为解释树的最终状态的最简单的历史。最简单的原因是，如果最终结果相同，它会修剪一些侧枝（即合并具有相同内容的分支）</p>
</dd>
<dt class="hdlist1" id="git-log---show-pulls"> <a class="anchor" href="#git-log---show-pulls"></a>--show-pulls </dt>
<dd>
<p>包括默认模式下的所有提交，但也包括任何与第一个父分支不相干但与后来的父分支相干的合并提交。这种模式有助于显示 "首次引入 "某个分支的合并提交。</p>
</dd>
<dt class="hdlist1" id="git-log---full-history"> <a class="anchor" href="#git-log---full-history"></a>--full-history </dt>
<dd>
<p>与默认模式相同，但不修剪一些历史记录。</p>
</dd>
<dt class="hdlist1" id="git-log---dense"> <a class="anchor" href="#git-log---dense"></a>--dense </dt>
<dd>
<p>只显示所选的提交，再加上一些才有意义的历史。</p>
</dd>
<dt class="hdlist1" id="git-log---sparse"> <a class="anchor" href="#git-log---sparse"></a>--sparse </dt>
<dd>
<p>简化历史中的所有提交都会显示出来。</p>
</dd>
<dt class="hdlist1" id="git-log---simplify-merges"> <a class="anchor" href="#git-log---simplify-merges"></a>--simplify-merges </dt>
<dd>
<p>为`--full-history`增加了一个选项，可以从结果的历史中删除一些不必要的合并，因为没有选定的提交对这次合并有贡献。</p>
</dd>
<dt class="hdlist1" id="git-log---ancestry-pathltgt"> <a class="anchor" href="#git-log---ancestry-pathltgt"></a>--ancestry-path[=&lt;提交&gt;] </dt>
<dd>
<p>When given a range of commits to display (e.g. <em>commit1..commit2</em> or <em>commit2 ^commit1</em>), and a commit &lt;commit&gt; in that range, only display commits in that range that are ancestors of &lt;commit&gt;, descendants of &lt;commit&gt;, or &lt;commit&gt; itself. If no commit is specified, use <em>commit1</em> (the excluded part of the range) as &lt;commit&gt;. Can be passed multiple times; if so, a commit is included if it is any of the commits given or if it is an ancestor or descendant of one of them.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>以下是更详细的解释。</p>
</div>
<div class="paragraph">
<p>假设你指定了 <code>foo</code> 作为 &lt;路径&gt;。 我们将把修改 <code>foo</code> 的提交称为 !TREESAME，其余的称为 TREESAME。 (在为 <code>foo</code> 过滤的差异中，它们看起来分别是不同的和相同的。）</p>
</div>
<div class="paragraph">
<p>在下文中，我们将始终引用同一个历史实例来说明简化设置之间的差异。 我们假设你在这个提交图中过滤的是一个文件 <code>foo</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	  .-A---M---N---O---P---Q
	 /     /   /   /   /   /
	I     B   C   D   E   Y
	 \   /   /   /   /   /
	  `-------------'   X</pre>
</div>
</div>
<div class="paragraph">
<p>历史 A---Q 的横线被认为是每次合并的第一个父本。 这些提交是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>&#8216;I`是初始提交，其中`foo`存在，内容是`asdf&#8217;<em>，文件`quux`存在，内容是`quux</em>'。初始提交与空树比较，所以`I`是！`TREESAME。</p>
</li>
<li>
<p>在`A`中，&#8216;foo`只包含`foo&#8217;'。</p>
</li>
<li>
<p>`B`包含与`A`相同的变化。 它的合并`M`是微不足道的，因此对所有父类来说是TREESAME。</p>
</li>
<li>
<p><code>C`没有改变`foo</code>，但是它的合并`N`将其改为`foobar''，所以它与任何父类都不存在TREESAME。</p>
</li>
<li>
<p>&#8216;D`将`foo`设置为`baz&#8217;<em>。它的合并项`O`将`N`和`D`的字符串合并为`foobarbaz</em>'；也就是说，它与任何父类都不是TREESAME。</p>
</li>
<li>
<p>&#8216;E`将`quux`改为`xyzzy&#8217;<em>，其合并的`P`将这些字符串合并为`quux xyzzy</em>'。`P&#8217;与`O&#8217;的关系是TREESAME，但与`E&#8217;不是。</p>
</li>
<li>
<p><code>X`是一个独立的根提交，添加了一个新文件`side</code>，<code>Y`修改了它。`Y`与`X`同为TREESAME。它的合并文件`Q`在`P`上添加了`side</code>，`Q`与`P`是同源，但与`Y`不是同源。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>rev-list`在历史中倒退，根据是否使用</code>--full-history`和/或父代重写（通过`--parents`或`--children`），包括或排除提交。以下设置是可用的。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-log--1"> <a class="anchor" href="#git-log--1"></a>默认模式 </dt>
<dd>
<p>如果提交的内容与任何父类不相干，则被包括在内（当然这一点可以改变，见下面的`--sparse`）。 如果该提交是一个合并，并且它与一个父类是同源的，则只跟随该父类。 (即使有几个TREESAME父类，也只跟随其中一个。) 否则，跟随所有父类。</p>
<div class="paragraph">
<p>这将实现：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	  .-A---N---O
	 /     /   /
	I---------D</pre>
</div>
</div>
<div class="paragraph">
<p>请注意，如果有TREESAME父类的话，只遵循TREESAME父类的规则，将`B&#8217;完全排除在考虑之外。 `C`是通过`N`考虑的，但也是TREESAME。 根提交是与空树比较的，所以`I`是!!TREESAME。</p>
</div>
<div class="paragraph">
<p>父/子关系只有在使用 <code>--parents</code> 选项的情况下才能看到，但这并不影响在默认模式下选择的提交，所以我们显示了父行。</p>
</div>
</dd>
<dt class="hdlist1" id="git-log---full-history-1"> <a class="anchor" href="#git-log---full-history-1"></a>--full-history 无父级重写的完整历史记录 </dt>
<dd>
<p>这种模式与默认模式有一点不同：总是跟随一个合并的所有父本，即使它与其中一个父本是TREESAME。 即使合并的一方有多个提交被包括在内，这也不意味着合并本身也是如此在这个例子中，我们得到</p>
<div class="listingblock">
<div class="content">
<pre>	I  A  B  N  D  O  P  Q</pre>
</div>
</div>
<div class="paragraph">
<p><code>M</code> 被排除在外，因为它与父母都是TREESAME。 <code>E</code> 、<code>C</code> 和`B` 都走了，但只有`B` 是 !TREESAME，所以其他的都没有出现。</p>
</div>
<div class="paragraph">
<p>请注意，如果没有父子重写，其实是不可能谈论提交之间的父子关系的，所以我们显示它们是不相连的。</p>
</div>
</dd>
<dt class="hdlist1" id="git-log---full-history-1-1"> <a class="anchor" href="#git-log---full-history-1-1"></a>--full-history 带父级重写功能的全历史记录 </dt>
<dd>
<p>普通的提交只有当它们是！TREESAME时才会被包括在内（尽管这一点可以改变，见下面的`--sparse`）。</p>
<div class="paragraph">
<p>合并总是被包括在内。 然而，他们的父级列表会被重写。沿着每个父级，修剪掉那些不包括自己的提交。 这样做的结果是</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	  .-A---M---N---O---P---Q
	 /     /   /   /   /
	I     B   /   D   /
	 \   /   /   /   /
	  `-------------'</pre>
</div>
</div>
<div class="paragraph">
<p>与上面的`--full-history`相比，没有重写。 请注意，<code>E`被修剪掉了，因为它是TREESAME，但是P的父列表被改写为包含`E`的父`I</code>。 同样的情况发生在`C`和`N`，以及`X`、<code>Y`和`Q</code>。</p>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>除了上述设置外，你还可以改变 TRESAME 是否会影响收录：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-log---dense-1"> <a class="anchor" href="#git-log---dense-1"></a>--dense </dt>
<dd>
<p>如果不与任何父类有TREESAME关系，则包括走过的承诺。</p>
</dd>
<dt class="hdlist1" id="git-log---sparse-1"> <a class="anchor" href="#git-log---sparse-1"></a>--sparse </dt>
<dd>
<p>所有走过的提交都包括在内。</p>
<div class="paragraph">
<p>请注意，如果没有`--full-history`，这仍然可以简化合并：如果父代之一是TREESAME，我们只跟随这个父代，所以合并的其他方面永远不会被走。</p>
</div>
</dd>
<dt class="hdlist1" id="git-log---simplify-merges-1"> <a class="anchor" href="#git-log---simplify-merges-1"></a>--simplify-merges </dt>
<dd>
<p>首先，按照`--full-history`与父级改写的相同方式建立一个历史图（见上文）。</p>
<div class="paragraph">
<p>然后根据以下规则将每个提交的 <code>C</code> 简化为最终历史中的替换 <code>C</code>：</p>
</div>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>将 "C "设为 "C"。</p>
</li>
<li>
<p>将`C'<code>的每个父类`P'替换成其简化的`P'</code>。 在这个过程中，放弃那些是其他父类的祖先的父类，或者是根部提交TREESAME的空树，并删除重复的父类，但注意不要放弃所有我们是TREESAME的父类。</p>
</li>
<li>
<p>如果在这次父级改写之后，&#8216;C&#8217;`是一个根或合并提交（有0个或&gt;1个父级），一个边界提交，或！TREESAME，那么它将被保留。 否则，它将被替换为其唯一的父类。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>通过与 <code>--full-history</code> 选项的父级改写进行比较，可以最好地显示其效果。 这个例子变成了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	  .-A---M---N---O
	 /     /       /
	I     B       D
	 \   /       /
	  `---------'</pre>
</div>
</div>
<div class="paragraph">
<p>注意 <code>N</code> 、<code>P</code> 和 <code>Q</code> 与 <code>--full-history</code> 的主要区别：</p>
</div>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p><code>N`的父列表中删除了`I</code>，因为它是另一个父`M`的一个祖先。 但是，`N`仍然存在，因为它是!TREESAME。</p>
</li>
<li>
<p><code>P`的父级列表也同样删除了`I</code>。 然后`P`被完全删除，因为它有一个父本，并且是TREESAME。</p>
</li>
<li>
<p><code>Q`的父列表中有`Y`简化为`X</code>。然后`X`被删除，因为它是一个TREESAME根。然后`Q`被完全删除，因为它有一个父级，是TREESAME。</p>
</li>
</ul>
</div>
</div>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>还有一种简化模式可用：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-log---ancestry-pathltgt-1"> <a class="anchor" href="#git-log---ancestry-pathltgt-1"></a>--ancestry-path[=&lt;提交&gt;] </dt>
<dd>
<p>将显示的提交限制在&lt;提交&gt;的祖先，或&lt;提交&gt;的后代，或&lt;提交&gt;本身。</p>
<div class="paragraph">
<p>作为一个用例，请考虑以下提交历史：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	    D---E-------F
	   /     \       \
	  B---C---G---H---I---J
	 /                     \
	A-------K---------------L--M</pre>
</div>
</div>
<div class="paragraph">
<p>有规律的 "D&#8230;&#8203;M "会计算出作为`M`的祖先的提交集合，但不包括作为`D`的祖先的提交。这对了解`M&#8217;的历史在`D&#8217;之后发生了什么很有用，也就是说`M&#8217;有什么东西是`D&#8217;没有的'。这个例子中的结果是所有的提交，除了`A`和`B`（当然还有`D`本身）。</p>
</div>
<div class="paragraph">
<p>然而，当我们想找出`M&#8217;中哪些提交被`D&#8217;引入的错误所污染而需要修复时，我们可能只想查看&#8217;D&#8230;&#8203;M&#8217;中实际上是`D&#8217;的后代的子集，即排除`C&#8217;和`K'。这正是`--ancestry-path`选项的作用。应用于&#8217;D&#8230;&#8203;M&#8217;范围，它的结果是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>		E-------F
		 \       \
		  G---H---I---J
			       \
				L--M</pre>
</div>
</div>
<div class="paragraph">
<p>我们也可以用`--ancestry-path=D`来代替`--ancestry-path`，这在应用于&#8217;D&#8230;&#8203;M&#8217;范围时意思相同，只是更加明确。</p>
</div>
<div class="paragraph">
<p>如果我们感兴趣的是这个范围内的某个主题，以及受该主题影响的所有提交，我们可能只想查看祖先路径中包含该主题的`D&#8230;&#8203;M`子集。 因此，以`--ancestry-path=H D&#8230;&#8203;M`为例，会形成以下结果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>		E
		 \
		  G---H---I---J
			       \
				L--M</pre>
</div>
</div>
<div class="paragraph">
<p>而`--ancestry-path=K D&#8230;&#8203;M`会形成以下结果</p>
</div>
<div class="listingblock">
<div class="content">
<pre>		K---------------L--M</pre>
</div>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>在讨论另一个选项，`--show-pulls`之前，我们需要创建一个新的历史实例。</p>
</div>
<div class="paragraph">
<p>用户在查看简化的提交历史时经常遇到的一个问题是，他们知道的对某个文件的修改提交并没有出现在该文件的简史中。让我们演示一个新的例子，并说明`--full-history`和`--simplify-merges`等选项在这种情况下是如何工作的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	  .-A---M-----C--N---O---P
	 /     / \  \  \/   /   /
	I     B   \  R-'`-Z'   /
	 \   /     \/         /
	  \ /      /\        /
	   `---X--'  `---Y--'</pre>
</div>
</div>
<div class="paragraph">
<p>在这个例子中，假设`I`创建了`file.txt`，并被`A`、<code>B`和`X`以不同方式修改。单亲提交的`C</code>、<code>Z`和`Y`没有修改`file.txt</code>。合并提交 <code>M`是通过解决合并冲突而产生的，包括了 `A `和 `B `的修改，因此与其中任何一个都不是同源的。然而，合并提交`R`是通过忽略`M`处的`file.txt`的内容，而只采用`X`处的`file.txt`的内容而产生的。因此，`R`与`X`是同源的，但不是`M</code>。最后，创建`N&#8217;的自然合并决议是取`file.txt`在`R&#8217;的内容，所以`N&#8217;与`R`是同源的，但不是`C`。 合并提交的 <code>O</code> 和 <code>P</code> 与它们的第一代父母是同源的，但与它们的第二代父母 <code>Z</code> 和 `Y `则不是同源的。</p>
</div>
<div class="paragraph">
<p>当使用默认模式时，`N&#8217;和`R`都有一个TREESAME父级，所以这些边被展示出来，其他边被忽略。由此产生的历史图是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	I---X</pre>
</div>
</div>
<div class="paragraph">
<p>当使用 <code>--full-history</code> 选项时，Git 会行走每条边。这将发现提交 <code>A</code> 和 <code>B</code> 以及合并 <code>M</code>，但也将揭示合并提交 <code>O</code> 和 <code>P</code> 。通过父级改写，得到的图是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	  .-A---M--------N---O---P
	 /     / \  \  \/   /   /
	I     B   \  R-'`--'   /
	 \   /     \/         /
	  \ /      /\        /
	   `---X--'  `------'</pre>
</div>
</div>
<div class="paragraph">
<p>这里，合并提交 <code>O</code> 和 <code>P</code> 带来了额外的输出，因为它们实际上并没有对 <code>file.txt</code> 做出改变。他们只是合并了一个基于 <code>file.txt</code> 旧版本的主题。这是在使用工作流程的仓库中常见的问题，在工作流程中，许多贡献者并行工作，并沿着一个主干合并他们的主题分支：不相关的合并出现在 <code>--full-history</code> 选项结果中。</p>
</div>
<div class="paragraph">
<p>当使用`--simplify-merges`选项时，提交的 <code>O</code> 和 <code>P</code> 从结果中消失。这是因为 <code>O</code> 和 <code>P</code> 重写的第二父本可以从它们的第一父本到达。这些边被移除，然后这些提交看起来就像与它们的父类一样的单亲提交。这也发生在提交 <code>N</code> 上，导致历史视图如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	  .-A---M--.
	 /     /    \
	I     B      R
	 \   /      /
	  \ /      /
	   `---X--'</pre>
</div>
</div>
<div class="paragraph">
<p>在这个视图中，我们看到了所有来自`A`，<code>B`和`X`的重要单亲变化。我们还可以看到仔细解决的合并`M`和不那么仔细解决的合并`R</code>。这些信息通常足以确定为什么`A`和`B`的提交在默认视图中从历史中 "消失 "了。然而，这种方法也有一些问题。</p>
</div>
<div class="paragraph">
<p>第一个问题是性能。与之前的任何选项不同，<code>--simplify-merges</code> 选项需要在返回一个结果之前走完整个提交历史。这可能使该选项难以用于非常大的仓库。</p>
</div>
<div class="paragraph">
<p>第二个问题是审计的问题。当许多贡献者在同一个版本库中工作时，哪些合并提交将一个变化引入到一个重要的分支是很重要的。上面有问题的合并`R`不可能是用来合并到一个重要分支的合并提交。相反，`N&#8217;是用来将`R&#8217;和`X&#8217;合并到重要分支的。这个提交可能有关于为什么`X&#8217;会覆盖`A&#8217;和`B&#8217;的修改的信息，在其提交信息中。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-log---show-pulls-1"> <a class="anchor" href="#git-log---show-pulls-1"></a>--show-pulls </dt>
<dd>
<p>除了在默认历史中显示的提交之外，还要显示每一个与第一个父本不相同但与后来的父本相同的合并提交。</p>
<div class="paragraph">
<p>当一个合并提交被 <code>--show-pulls</code> 选项包含时，该合并被视为从另一个分支 “拉取” 来的修改。在这个例子中使用 <code>--show-pulls</code> 选项时（没有其他选项），得到的图是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	I---X---R---N</pre>
</div>
</div>
<div class="paragraph">
<p>这里，合并后的提交`R`和`N`被包括在内，因为它们分别将提交`X`和`R`拉到了基础分支。这些合并是`A`和`B`的提交没有出现在默认历史中的原因。</p>
</div>
<div class="paragraph">
<p>当 <code>--show-pulls</code> 与 <code>--simplify-merges</code> 选项配对时，该图包括所有必要的信息：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	  .-A---M--.   N
	 /     /    \ /
	I     B      R
	 \   /      /
	  \ /      /
	   `---X--'</pre>
</div>
</div>
<div class="paragraph">
<p>请注意，由于`M`可以从`R`到达，从`N`到`M`的边被简化掉了。然而，`N`仍然作为一个重要的提交出现在历史中，因为它把`R`的修改 "拉 "进了主分支。</p>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p><code>--simplify-by-decoration</code> 选项允许你只查看历史拓扑的全貌，省略那些没有被标签引用的提交。 如果 (1) 提交被标签引用，或者 (2) 提交改变了命令行上给出的路径内容，则被标记为 TREESAME（换句话说，按照上述历史简化规则保留）。 所有其他的提交都被标记为 TREESAME（会被简化掉）。</p>
</div>
</div>
<div class="sect2">
<h3 id="_承诺订购"><a class="anchor" href="#_承诺订购"></a>承诺订购</h3>
<div class="paragraph">
<p>默认情况下，提交的内容是按时间顺序倒序显示的。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-log---date-order"> <a class="anchor" href="#git-log---date-order"></a>--date-order </dt>
<dd>
<p>在显示所有子代之前不显示父代，否则按提交时间戳顺序显示提交。</p>
</dd>
<dt class="hdlist1" id="git-log---author-date-order"> <a class="anchor" href="#git-log---author-date-order"></a>--author-date-order </dt>
<dd>
<p>在显示所有子代之前不显示父代，否则按作者时间戳顺序显示提交。</p>
</dd>
<dt class="hdlist1" id="git-log---topo-order"> <a class="anchor" href="#git-log---topo-order"></a>--topo-order </dt>
<dd>
<p>在显示所有子代之前不显示父代，并避免显示多行历史交错的提交。</p>
<div class="paragraph">
<p>例如，在这样的一个提交历史中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>    ---1----2----4----7
	\	       \
	 3----5----6----8---</pre>
</div>
</div>
<div class="paragraph">
<p>其中数字表示提交时间戳的顺序，<code>git rev-list`和带有</code>--date-order`的朋友显示提交的时间戳顺序。8 7 6 5 4 3 2 1.</p>
</div>
<div class="paragraph">
<p>如果使用`--topo-order`，它们会显示8 6 5 3 7 4 2 1（或8 7 4 2 6 5 3 1）；一些较早的提交会显示在较新的提交之前，以避免显示两个平行开发轨道的提交混在一起。</p>
</div>
</dd>
<dt class="hdlist1" id="git-log---reverse"> <a class="anchor" href="#git-log---reverse"></a>--reverse </dt>
<dd>
<p>以相反的顺序输出选择显示的提交（见上面的提交限制部分）。不能与`--walk-reflogs`结合使用。</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_对象遍历"><a class="anchor" href="#_对象遍历"></a>对象遍历</h3>
<div class="paragraph">
<p>这些选项主要是针对Git存储库的打包。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-log---no-walksortedunsorted"> <a class="anchor" href="#git-log---no-walksortedunsorted"></a>--no-walk[=(sorted|unsorted)] </dt>
<dd>
<p>只显示给定的提交，但不遍历其祖先。 如果指定了范围，这一点就没有影响。如果给了参数 <code>unsorted</code>，提交会按照命令行上的顺序显示。否则（如果 <code>sorted</code> 或者没有给出参数），提交将按照提交时间的倒序显示。 不能与 <code>--graph</code> 选项结合使用。</p>
</dd>
<dt class="hdlist1" id="git-log---do-walk"> <a class="anchor" href="#git-log---do-walk"></a>--do-walk </dt>
<dd>
<p>覆盖之前的 <code>--no-walk</code> 。</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_承诺格式化"><a class="anchor" href="#_承诺格式化"></a>承诺格式化</h3>
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-log---prettyltgt"> <a class="anchor" href="#git-log---prettyltgt"></a>--pretty[=&lt;格式&gt;] </dt>
<dt class="hdlist1" id="git-log---formatltgt"> <a class="anchor" href="#git-log---formatltgt"></a>--format=&lt;格式&gt; </dt>
<dd>
<p>以指定的格式打印提交日志的内容，其中'&lt;format&gt;'可以是&#8217;oneline'、<em>short</em>、<em>medium</em>、<em>full</em>、<em>fuller</em>、<em>reference</em>、<em>email</em>、<em>raw</em>、<em>format:&lt;string&gt;'和&#8217;tformat:&lt;string&gt;'之一。 当</em>&lt;format&gt;'不是上述任何一种，并且其中有'%placeholder&#8217;时，它的作用就像给出'--pretty=tformat:&lt;format&gt;'一样。</p>
<div class="paragraph">
<p>参见 "PRETTY FORMATS "部分，了解每种格式的一些额外细节。 当'=&lt;格式&gt;'部分被省略时，它默认为&#8217;中等'。</p>
</div>
<div class="paragraph">
<p>注意：你可以在版本库配置中指定默认的漂亮格式（见<a href='{{< relurl "docs/git-config/zh_HANS-CN" >}}'>git-config[1]</a>）。</p>
</div>
</dd>
<dt class="hdlist1" id="git-log---abbrev-commit"> <a class="anchor" href="#git-log---abbrev-commit"></a>--abbrev-commit </dt>
<dd>
<p>不要显示完整的40字节的十六进制提交对象名称，而是显示一个前缀，以唯一的方式命名该对象。 "--abbrev=&lt;n&gt;"选项可以用来指定前缀的最小长度（如果显示的话，它也会修改diff输出）。</p>
<div class="paragraph">
<p>这应该使"--pretty=oneline "对于使用80列终端的人来说更容易阅读。</p>
</div>
</dd>
<dt class="hdlist1" id="git-log---no-abbrev-commit"> <a class="anchor" href="#git-log---no-abbrev-commit"></a>--no-abbrev-commit </dt>
<dd>
<p>显示完整的40字节十六进制的提交对象名称。这否定了`--abbrev-commit`，无论是明确的还是由其他选项如"--oneline "暗示的。它还覆盖了`log.abbrevCommit`变量。</p>
</dd>
<dt class="hdlist1" id="git-log---oneline"> <a class="anchor" href="#git-log---oneline"></a>--oneline </dt>
<dd>
<p>这是"--pretty=oneline --abbrev-commit "的简写，一起使用。</p>
</dd>
<dt class="hdlist1" id="git-log---encodingltgt"> <a class="anchor" href="#git-log---encodingltgt"></a>--encoding=&lt;编码&gt; </dt>
<dd>
<p>提交对象会在其编码头中记录日志信息使用的字符编码；该选项可用于告诉命令以用户偏好的编码重新编码提交日志信息。 对于非底层命令，默认编码为 UTF-8。需要注意的是，如果对象声称以 <code>X</code> 编码，而我们以 <code>X</code> 输出，我们将逐字输出该对象；这意味着原始提交中的无效序列可能会被复制到输出中。同样，如果 iconv(3) 无法转换提交，我们也会静静地逐字输出原始对象。</p>
</dd>
<dt class="hdlist1" id="git-log---expand-tabsltngt"> <a class="anchor" href="#git-log---expand-tabsltngt"></a>--expand-tabs=&lt;n&gt; </dt>
<dt class="hdlist1" id="git-log---expand-tabs"> <a class="anchor" href="#git-log---expand-tabs"></a>--expand-tabs </dt>
<dt class="hdlist1" id="git-log---no-expand-tabs"> <a class="anchor" href="#git-log---no-expand-tabs"></a>--no-expand-tabs </dt>
<dd>
<p>在输出中显示之前，在日志信息中进行标签扩展（用足够的空格替换每个标签，以填充到下一个显示列的 <em>&lt;n&gt;</em> 的倍数）。 <code>--expand-tabs</code> 是 <code>--expand-tabs=8</code> 的简写，<code>--no-expand-tabs</code> 是 <code>--expand-tabs=0</code> 的简写，它禁止标签扩展。</p>
<div class="paragraph">
<p>默认情况下，标签会以漂亮的格式展开，将日志信息缩进4个空格（即 "中"，这是默认的，"全"，和 "更全"）。</p>
</div>
</dd>
<dt class="hdlist1" id="git-log---notesltgt"> <a class="anchor" href="#git-log---notesltgt"></a>--notes[=&lt;引用&gt;] </dt>
<dd>
<p>在显示提交日志信息时，显示注释提交的说明（见<a href='{{< relurl "docs/git-notes/zh_HANS-CN" >}}'>git-notes[1]</a>）。 这是`git log`、<code>git show`和`git whatchanged`命令的默认设置，当命令行中没有给出</code>--pretty`、<code>--format`或</code>--oneline`选项时。</p>
<div class="paragraph">
<p>默认情况下，显示的注释来自于`core.notesRef`和`notes.displayRef`变量（或相应的环境覆盖）中列出的注释参考。更多细节见<a href='{{< relurl "docs/git-config/zh_HANS-CN" >}}'>git-config[1]</a>。</p>
</div>
<div class="paragraph">
<p>有了一个可选的 <em>&lt;引用&gt;</em> 参数，就可以使用引用来寻找要显示的笔记。 当引用以 <code>refs/notes/</code> 开头时，可以指定完整的引用名称；当它以 <code>notes/</code> 开头时， <code>refs/</code> ，否则 <code>refs/notes/</code> 前缀，形成引用的全名。</p>
</div>
<div class="paragraph">
<p>多个&#8212;&#8203;音符选项可以组合起来，控制哪些音符被显示。例如。"--notes=foo "将只显示来自 "refs/notes/foo "的注释；"--notes=foo --notes "将同时显示来自 "refs/notes/foo "和默认注释的注释。</p>
</div>
</dd>
<dt class="hdlist1" id="git-log---no-notes"> <a class="anchor" href="#git-log---no-notes"></a>--no-notes </dt>
<dd>
<p>不显示注释。这否定了上面的`--notes`选项，因为它重新设置了显示注释的注释列表。 选项按照命令行给出的顺序进行解析，因此，例如"--notes --notes=foo --no-notes --notes=bar "将只显示来自 "refs/notes/bar "的注释。</p>
</dd>
<dt class="hdlist1" id="git-log---show-notes-by-default"> <a class="anchor" href="#git-log---show-notes-by-default"></a>--show-notes-by-default </dt>
<dd>
<p>显示默认备注，除非给出了显示特定备注的选项。</p>
</dd>
<dt class="hdlist1" id="git-log---show-notesltgt"> <a class="anchor" href="#git-log---show-notesltgt"></a>--show-notes[=&lt;引用&gt;] </dt>
<dt class="hdlist1" id="git-log---no-standard-notes"> <a class="anchor" href="#git-log---no-standard-notes"></a>--[no-]standard-notes </dt>
<dd>
<p>这些选项已被废弃。请使用上面的 --notes/--no-notes 选项来代替。</p>
</dd>
<dt class="hdlist1" id="git-log---show-signature"> <a class="anchor" href="#git-log---show-signature"></a>--show-signature </dt>
<dd>
<p>通过将签名传递给 <code>gpg --verify</code> 来检查已签名的提交对象的有效性，并显示输出。</p>
</dd>
</dl>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-log---relative-date"> <a class="anchor" href="#git-log---relative-date"></a>--relative-date </dt>
<dd>
<p>`--date=relative`的同义词。</p>
</dd>
<dt class="hdlist1" id="git-log---dateltgt"> <a class="anchor" href="#git-log---dateltgt"></a>--date=&lt;格式&gt; </dt>
<dd>
<p>只对以人类可读格式显示的日期生效，例如使用`--pretty`时。<code>log.date`配置变量为日志命令的</code>--date`选项设置默认值。默认情况下，日期显示在原始时区（提交者或作者的时区）。如果`-local`被附加到格式中（例如，<code>iso-local</code>），就会使用用户的本地时区。</p>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p><code>--date=relative`显示相对于当前时间的日期，例如：`2小时前''。</code>--local`选项对`--date=relative`没有影响。</p>
</div>
<div class="paragraph">
<p><code>--date=local`是</code>--date=default-local`的一个别名。</p>
</div>
<div class="paragraph">
<p><code>--date=iso</code>（或 <code>--date=iso8601</code> ）以类似 ISO 8601 的格式显示时间戳。 与严格的 ISO 8601 格式的区别是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>用空格代替`T`日期/时间分隔符</p>
</li>
<li>
<p>时间和时区之间的空间</p>
</li>
<li>
<p>时区的小时和分钟之间没有冒号</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>--date=iso-strict</code>（或`--date=iso8601-strict`）显示严格的ISO 8601格式的时间戳。</p>
</div>
<div class="paragraph">
<p><code>--date=rfc</code>（或`--date=rfc2822`）显示RFC 2822格式的时间戳，经常出现在电子邮件中。</p>
</div>
<div class="paragraph">
<p><code>--date=short`只显示日期，而不是时间，格式为`YYYY-MM-DD</code>。</p>
</div>
<div class="paragraph">
<p><code>--date=raw`显示日期为自纪元以来的秒数（1970-01-01 00:00:00 UTC），后面是空格，然后是时区为UTC的偏移量（一个</code>+<code>或</code>-<code>的四位数字；前两位是小时，后两位是分钟）。也就是说，就像时间戳的格式为`strftime("%s %z")</code>)。 请注意，`-local`选项不影响自始至终的秒数值（它总是以UTC为单位），但会切换伴随的时区值。</p>
</div>
<div class="paragraph">
<p>`--date=human`如果时区与当前时区不匹配，则显示时区，如果匹配则不打印整个日期（即对于 "今年 "的日期，跳过打印年份，但如果是最近几天的日期，也跳过整个日期本身，我们可以只说是哪个工作日）。 对于较早的日期，小时和分钟也被省略了。</p>
</div>
<div class="paragraph">
<p><code>--date=unix`显示日期为Unix纪元时间戳（自1970年以来的秒数）。 与</code>--raw`一样，这总是以UTC为单位，因此`--local`没有影响。</p>
</div>
<div class="paragraph">
<p><code>--date=format:...</code> 将格式 <code>...</code> 输入到系统的 <code>strftime</code> 中，%z 和 %Z 除外，它们由内部处理。 使用 <code>--date=format:%c</code>，以系统语言首选的格式显示日期。 有关格式占位符的完整列表，请参阅 <code>strftime</code> 手册。使用 <code>-local</code> 时，正确的语法是 <code>--date=format-local:...</code>。</p>
</div>
<div class="paragraph">
<p><code>--date=default`是默认格式，基于ctime(3)输出。 它仅仅在一行中显示缩写的星期、缩写的月份、一月中的第几天、"HH:MM:SS "格式的小时-分钟-秒，然后是年份，除非使用本地时区，在末尾都会加上时区信息，例如`Thu Jan 1 00:00:00 1970 +0000</code>。</p>
</div>
</div>
</div>
</dd>
<dt class="hdlist1" id="git-log---parents"> <a class="anchor" href="#git-log---parents"></a>--parents </dt>
<dd>
<p>也可以打印提交的父类（以 "提交父类&#8230;&#8203; "的形式）。 也可以启用父级改写，见上面的 "历史简化"。</p>
</dd>
<dt class="hdlist1" id="git-log---children"> <a class="anchor" href="#git-log---children"></a>--children </dt>
<dd>
<p>同时打印提交的子项（以 "提交子项&#8230;&#8203; "的形式）。 也可以启用父级改写，见上面的 "历史简化"。</p>
</dd>
<dt class="hdlist1" id="git-log---left-right"> <a class="anchor" href="#git-log---left-right"></a>--left-right </dt>
<dd>
<p>标明提交可以从对称性差异的哪一边到达。 左边的提交以 <code>&lt;</code> 为前缀，右边的则以 <code>&gt;</code> 为前缀。 如果与 <code>--boundary</code> 结合，这些提交的前缀为 <code>-</code>。</p>
<div class="paragraph">
<p>例如，如果你有这样的拓扑结构：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	     y---b---b  branch B
	    / \ /
	   /   .
	  /   / \
	 o---x---a---a  branch A</pre>
</div>
</div>
<div class="paragraph">
<p>你会得到这样的输出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	$ git rev-list --left-right --boundary --pretty=oneline A...B

	&gt;bbbbbbb... 3rd on b
	&gt;bbbbbbb... 2nd on b
	&lt;aaaaaaa... 3rd on a
	&lt;aaaaaaa... 2nd on a
	-yyyyyyy... 1st on b
	-xxxxxxx... 1st on a</pre>
</div>
</div>
</dd>
<dt class="hdlist1" id="git-log---graph"> <a class="anchor" href="#git-log---graph"></a>--graph </dt>
<dd>
<p>在输出的左手边绘制基于文本的提交历史图表。 这可能会导致在提交之间打印出额外的行，以便正确地绘制图形历史。 不能与`--no-walk`结合使用。</p>
<div class="paragraph">
<p>这可以使父代改写，见上面的&#8217;历史简化'。</p>
</div>
<div class="paragraph">
<p>这意味着默认情况下是`--topo-order`选项，但也可以指定`--date-order`选项。</p>
</div>
</dd>
<dt class="hdlist1" id="git-log---show-linear-breakltgt"> <a class="anchor" href="#git-log---show-linear-breakltgt"></a>--show-linear-break[=&lt;阻隔&gt;] </dt>
<dd>
<p>如果不使用 --graph，所有的历史分支都会被压扁，这就很难看出两个连续的提交并不属于一个线性分支。在这种情况下，该选项会在它们之间设置一个障碍。如果指定了"&lt;barrier&gt;"，就会显示这个字符串，而不是默认的。</p>
</dd>
</dl>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_漂亮的格式"><a class="anchor" href="#_漂亮的格式"></a>漂亮的格式</h2>
<div class="sectionbody">
<div class="paragraph">
<p>如果提交是一个合并，并且如果pretty-format不是 "oneline"、"email "或 "raw"，那么在 "Author: "一行之前会插入一个附加行。 这一行的开头是 "Merge:这一行以 "Merge: "开头，并打印出祖先提交的哈希值，用空格分隔。 请注意，如果你限制了你的历史视图，那么列出的提交不一定是*直接*父级提交的列表：例如，如果你只对与某个目录或文件有关的修改感兴趣。</p>
</div>
<div class="paragraph">
<p>有几种内置的格式，你可以通过将 pretty.&lt;名称&gt; 配置选项设置为另一种格式名称或 <em>format:</em> 字符串来定义额外的格式，如下所述（见 <a href='{{< relurl "docs/git-config/zh_HANS-CN" >}}'>git-config[1]</a> ）。下面是内置格式的细节：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>oneline</em></p>
<div class="literalblock">
<div class="content">
<pre>&lt;哈希值&gt; &lt;标题行&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>这个设计是为了尽可能的紧凑。</p>
</div>
</li>
<li>
<p><em>short</em></p>
<div class="literalblock">
<div class="content">
<pre>承诺&lt;hash&gt;
作者。&lt;作者&gt;的情况</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;标题行&gt;</pre>
</div>
</div>
</li>
<li>
<p><em>medium</em></p>
<div class="literalblock">
<div class="content">
<pre>commit &lt;哈希值&gt;
Author: &lt;作者&gt;
Date:   &lt;提交日期&gt;</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;标题行&gt;</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;完整的提交信息</pre>
</div>
</div>
</li>
<li>
<p><em>full</em></p>
<div class="literalblock">
<div class="content">
<pre>承诺&lt;hash&gt;
作者。&lt; Author&gt;
承诺。&lt;committer&gt;（提交者）。</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;标题行&gt;</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;完整的提交信息</pre>
</div>
</div>
</li>
<li>
<p><em>fuller</em></p>
<div class="literalblock">
<div class="content">
<pre>commit &lt;哈希值&gt;
Author:     &lt;作者&gt;
AuthorDate: &lt;作者提交日期&gt;
Commit:     &lt;提交者&gt;
CommitDate: &lt;提交者提交日期&gt;</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;标题行&gt;</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;完整的提交信息</pre>
</div>
</div>
</li>
<li>
<p>‘引用’</p>
<div class="literalblock">
<div class="content">
<pre>&lt;缩写哈希值&gt;（&lt;标题行&gt;，&lt;简短的作者日期&gt;）</pre>
</div>
</div>
<div class="paragraph">
<p>这种格式用于在提交信息中引用另一个提交，与`--pretty='format:%C(auto)%h (%s, %ad)'相同。 默认情况下，日期的格式为`--date=short`，除非明确指定其他`--date`选项。 与任何带有格式占位符的`format:<code>一样，其输出不受其他选项的影响，如</code>--decorate`和`--walk-reflogs`。</p>
</div>
</li>
<li>
<p><em>email</em></p>
<div class="literalblock">
<div class="content">
<pre>From &lt;哈希&gt; &lt;日期&gt;
From: &lt;作者&gt;
Date: &lt;作者提交日期&gt;
Subject: [PATCH] &lt;标题行&gt;</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;完整的提交信息</pre>
</div>
</div>
</li>
<li>
<p><em>mboxrd</em></p>
<div class="paragraph">
<p>和 "email "一样，但提交信息中以 "From "开头的行（前面有零个或多个"&gt;"）用"&gt;"引出，这样就不会被混淆为开始了一个新的提交。</p>
</div>
</li>
<li>
<p><em>raw</em></p>
<div class="paragraph">
<p>原始 "格式显示的是整个提交对象中存储的内容。 值得注意的是，无论是否使用了 --abbrev 或 --no-abbrev，哈希值都会被完整地显示出来，而&#8217;parent&#8217;信息会显示真正的父级提交，不会考虑移花接木或历史简化。注意，这种格式会影响提交的显示方式，但不会影响diff的显示方式，比如用`git log --raw`来显示。要获得原始差异格式的完整对象名称，请使用`--no-abbrev`。</p>
</div>
</li>
<li>
<p><em>format:&lt;格式字符串&gt;</em></p>
<div class="paragraph">
<p><em>format:&lt;格式字符串</em> 格式允许你指定要显示的信息。它的工作原理有点像 printf 格式，但有一个明显的例外，那就是换行符是 <em>%n</em> 而不是 <em>\n</em>。</p>
</div>
<div class="paragraph">
<p>例如，<em>format: "The author of %h was %an, %ar%nThe title was &gt;&gt;%s&lt;&lt;%n"</em> 会显示这样的内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>fe6e0ee的作者是Junio C Hamano, 23小时前
标题是 &gt;&gt;t4119: 测试传统diff输入的自动计算-p&lt;n&gt;。</pre>
</div>
</div>
<div class="paragraph">
<p>占位符是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>占位符，可扩展为一个字面字符：</p>
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-log-emnem"> <a class="anchor" href="#git-log-emnem"></a><em>%n</em> </dt>
<dd>
<p>换行</p>
</dd>
<dt class="hdlist1" id="git-log-emem"> <a class="anchor" href="#git-log-emem"></a><em>%%</em> </dt>
<dd>
<p>一个原始的'%'</p>
</dd>
<dt class="hdlist1" id="git-log-emx00em"> <a class="anchor" href="#git-log-emx00em"></a><em>%x00</em> </dt>
<dd>
<p><em>%x</em> 后跟两个十六进制数字，会被一个包含十六进制数字值的字节替换（在本文档的其余部分，我们称之为 “字面格式化代码”）。</p>
</dd>
</dl>
</div>
</li>
<li>
<p>影响后面占位符的格式化的占位符：</p>
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-log-emCredem"> <a class="anchor" href="#git-log-emCredem"></a><em>%Cred</em> </dt>
<dd>
<p>切换颜色为红色</p>
</dd>
<dt class="hdlist1" id="git-log-emCgreenem"> <a class="anchor" href="#git-log-emCgreenem"></a><em>%Cgreen</em> </dt>
<dd>
<p>切换颜色为绿色</p>
</dd>
<dt class="hdlist1" id="git-log-emCblueem"> <a class="anchor" href="#git-log-emCblueem"></a><em>%Cblue</em> </dt>
<dd>
<p>将颜色改为蓝色</p>
</dd>
<dt class="hdlist1" id="git-log-emCresetem"> <a class="anchor" href="#git-log-emCresetem"></a><em>%Creset</em> </dt>
<dd>
<p>重置颜色</p>
</dd>
<dt class="hdlist1" id="git-log-emC82308203em"> <a class="anchor" href="#git-log-emC82308203em"></a><em>%C(&#8230;&#8203;)</em> </dt>
<dd>
<p>颜色规范，如<a href='{{< relurl "docs/git-config/zh_HANS-CN" >}}'>git-config[1]</a>的 "配置文件 "部分中的数值描述。 默认情况下，只有在启用日志输出时才会显示颜色（通过 <code>color.diff</code>, <code>color.ui</code>, 或 <code>--color</code>, 如果我们要去终端，要尊重前者的`auto`设置）。<code>%C(auto,...)`被接受为默认的历史同义词（例如，</code>%C(auto,red)<code>）。指定</code>%C(always,&#8230;&#8203;)<code>将显示颜色，即使没有启用颜色（尽管考虑使用</code>--color=always`来启用整个输出的颜色，包括这个格式和其他任何git可能的颜色）。 <code>auto`单独使用（即</code>%C(auto)`）将在下一个占位符上开启自动着色，直到再次切换颜色。</p>
</dd>
<dt class="hdlist1" id="git-log-emmem"> <a class="anchor" href="#git-log-emmem"></a><em>%m</em> </dt>
<dd>
<p>左（<code>&lt;</code>）、右（<code>&gt;</code>）或边界（<code>-</code>）标记</p>
</dd>
<dt class="hdlist1" id="git-log-emwltwgtlti1gtlti2gtem"> <a class="anchor" href="#git-log-emwltwgtlti1gtlti2gtem"></a><em>%w([&lt;w&gt;[,&lt;i1&gt;[,&lt;i2&gt;]]])</em> </dt>
<dd>
<p>开关包行，就像 <a href='{{< relurl "docs/git-shortlog/zh_HANS-CN" >}}'>git-shortlog[1]</a> 的 -w 选项。</p>
</dd>
<dt class="hdlist1" id="git-log-emltltNgttruncltruncmtruncem"> <a class="anchor" href="#git-log-emltltNgttruncltruncmtruncem"></a><em>%&lt;(&lt;N&gt;[,trunc|ltrunc|mtrunc])</em> </dt>
<dd>
<p>使下一个占位符至少占用 N 列宽，必要时在右侧填充空格。 如果输出超过 N 列，可选择在左侧（ltrunc）<code>..ft</code>、中间（mtrunc）<code>mi..le</code> 或末尾（trunc）<code>rig..</code> 截断（用省略号 <em>..</em> ）。 注意 1：截断只在 N &gt;= 2 时有效。 注 2：N 和 M（见下文）值周围的空格为可选项。 注 3：表情符号和其他宽字符将占用两个显示列，可能会超出列边界。 注 4：分解字符组合标记可能会在填充边界处错位。</p>
</dd>
<dt class="hdlist1" id="git-log-emltltMgtem"> <a class="anchor" href="#git-log-emltltMgtem"></a><em>%&lt;|(&lt;M&gt;)</em> </dt>
<dd>
<p>使下一个占位符至少显示到第 M 列，必要时在右侧填充空格。 从终端窗口右侧边缘测量的列位置使用负 M 值。</p>
</dd>
<dt class="hdlist1" id="git-log-emgtltNgtememgtltMgtem"> <a class="anchor" href="#git-log-emgtltNgtememgtltMgtem"></a><em>%&gt;(&lt;N&gt;)</em>, <em>%&gt;|(&lt;M&gt;)</em> </dt>
<dd>
<p>分别类似于 <em>%&lt;( &lt;N&gt; )</em> 、<em>%&lt;|( &lt;M&gt; )</em>，但在左侧填充空格</p>
</dd>
<dt class="hdlist1" id="git-log-emgtgtltNgtememgtgtltMgtem"> <a class="anchor" href="#git-log-emgtgtltNgtememgtgtltMgtem"></a><em>%&gt;&gt;(&lt;N&gt;)</em>, <em>%&gt;&gt;|(&lt;M&gt;)</em> </dt>
<dd>
<p>分别类似于'%&gt;(&lt;N&gt;)<em>、</em>%&gt;|(&lt;M&gt;)'，只是如果下一个占位符占用的空间比给定的多，并且其左侧有空格，则使用这些空格</p>
</dd>
<dt class="hdlist1" id="git-log-emgtltltNgtememgtltltMgtem"> <a class="anchor" href="#git-log-emgtltltNgtememgtltltMgtem"></a><em>%&gt;&lt;(&lt;N&gt;)</em>, <em>%&gt;&lt;|(&lt;M&gt;)</em> </dt>
<dd>
<p>分别类似于'%&lt;( &lt;N&gt; )' 和 <em>%&lt;|( &lt;M&gt; )</em>，但两边都有填充（即文本居中）</p>
</dd>
</dl>
</div>
</li>
<li>
<p>占位符，扩展到从提交中提取的信息：</p>
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-log-emHem"> <a class="anchor" href="#git-log-emHem"></a><em>%H</em> </dt>
<dd>
<p>提交的哈希值</p>
</dd>
<dt class="hdlist1" id="git-log-emhem"> <a class="anchor" href="#git-log-emhem"></a><em>%h</em> </dt>
<dd>
<p>简称提交哈希</p>
</dd>
<dt class="hdlist1" id="git-log-emTem"> <a class="anchor" href="#git-log-emTem"></a><em>%T</em> </dt>
<dd>
<p>目录树哈希值</p>
</dd>
<dt class="hdlist1" id="git-log-emtem"> <a class="anchor" href="#git-log-emtem"></a><em>%t</em> </dt>
<dd>
<p>简称树形哈希</p>
</dd>
<dt class="hdlist1" id="git-log-emPem"> <a class="anchor" href="#git-log-emPem"></a><em>%P</em> </dt>
<dd>
<p>父类哈希值</p>
</dd>
<dt class="hdlist1" id="git-log-empem"> <a class="anchor" href="#git-log-empem"></a><em>%p</em> </dt>
<dd>
<p>缩写的父母哈希值</p>
</dd>
<dt class="hdlist1" id="git-log-emanem"> <a class="anchor" href="#git-log-emanem"></a><em>%an</em> </dt>
<dd>
<p>作者名</p>
</dd>
<dt class="hdlist1" id="git-log-emaNem"> <a class="anchor" href="#git-log-emaNem"></a><em>%aN</em> </dt>
<dd>
<p>作者名（关于 .mailmap，请参见 <a href='{{< relurl "docs/git-shortlog/zh_HANS-CN" >}}'>git-shortlog[1]</a> 或 <a href='{{< relurl "docs/git-blame/zh_HANS-CN" >}}'>git-blame[1]</a></p>
</dd>
<dt class="hdlist1" id="git-log-emaeem"> <a class="anchor" href="#git-log-emaeem"></a><em>%ae</em> </dt>
<dd>
<p>作者电子邮箱</p>
</dd>
<dt class="hdlist1" id="git-log-emaEem"> <a class="anchor" href="#git-log-emaEem"></a><em>%aE</em> </dt>
<dd>
<p>作者电子邮件（关于 .mailmap，请参见 <a href='{{< relurl "docs/git-shortlog/zh_HANS-CN" >}}'>git-shortlog[1]</a> 或 <a href='{{< relurl "docs/git-blame/zh_HANS-CN" >}}'>git-blame[1]</a></p>
</dd>
<dt class="hdlist1" id="git-log-emalem"> <a class="anchor" href="#git-log-emalem"></a><em>%al</em> </dt>
<dd>
<p>作者电子邮件的本地部分（<em>@</em> 符号之前的部分）</p>
</dd>
<dt class="hdlist1" id="git-log-emaLem"> <a class="anchor" href="#git-log-emaLem"></a><em>%aL</em> </dt>
<dd>
<p>尊重 .mailmap 作者的本地部分（参见 <em>%al</em> ），参见 <a href='{{< relurl "docs/git-shortlog/zh_HANS-CN" >}}'>git-shortlog[1]</a> 或 <a href='{{< relurl "docs/git-blame/zh_HANS-CN" >}}'>git-blame[1]</a>)</p>
</dd>
<dt class="hdlist1" id="git-log-emadem"> <a class="anchor" href="#git-log-emadem"></a><em>%ad</em> </dt>
<dd>
<p>作者日期（格式尊重&#8212;&#8203;date=选项</p>
</dd>
<dt class="hdlist1" id="git-log-emaDem"> <a class="anchor" href="#git-log-emaDem"></a><em>%aD</em> </dt>
<dd>
<p>作者日期，RFC2822风格</p>
</dd>
<dt class="hdlist1" id="git-log-emarem"> <a class="anchor" href="#git-log-emarem"></a><em>%ar</em> </dt>
<dd>
<p>作者日期，相对</p>
</dd>
<dt class="hdlist1" id="git-log-ematem"> <a class="anchor" href="#git-log-ematem"></a><em>%at</em> </dt>
<dd>
<p>作者日期，UNIX时间戳</p>
</dd>
<dt class="hdlist1" id="git-log-emaiem"> <a class="anchor" href="#git-log-emaiem"></a><em>%ai</em> </dt>
<dd>
<p>作者日期，类似ISO 8601的格式</p>
</dd>
<dt class="hdlist1" id="git-log-emaIem"> <a class="anchor" href="#git-log-emaIem"></a><em>%aI</em> </dt>
<dd>
<p>作者日期，严格的ISO 8601格式</p>
</dd>
<dt class="hdlist1" id="git-log-emasem"> <a class="anchor" href="#git-log-emasem"></a><em>%as</em> </dt>
<dd>
<p>作者日期，短格式（ <code>YYYY-MM-DD</code> ）</p>
</dd>
<dt class="hdlist1" id="git-log-emahem"> <a class="anchor" href="#git-log-emahem"></a><em>%ah</em> </dt>
<dd>
<p>作者日期，以易读形式呈现（就像 <a href='{{< relurl "docs/git-rev-list/zh_HANS-CN" >}}'>git-rev-list[1]</a> 的 <code>--date=human</code> 选项）</p>
</dd>
<dt class="hdlist1" id="git-log-emcnem"> <a class="anchor" href="#git-log-emcnem"></a><em>%cn</em> </dt>
<dd>
<p>提交者名称</p>
</dd>
<dt class="hdlist1" id="git-log-emcNem"> <a class="anchor" href="#git-log-emcNem"></a><em>%cN</em> </dt>
<dd>
<p>提交者名称（尊重 .mailmap，参见 <a href='{{< relurl "docs/git-shortlog/zh_HANS-CN" >}}'>git-shortlog[1]</a> 或 <a href='{{< relurl "docs/git-blame/zh_HANS-CN" >}}'>git-blame[1]</a></p>
</dd>
<dt class="hdlist1" id="git-log-emceem"> <a class="anchor" href="#git-log-emceem"></a><em>%ce</em> </dt>
<dd>
<p>提交者电子邮箱</p>
</dd>
<dt class="hdlist1" id="git-log-emcEem"> <a class="anchor" href="#git-log-emcEem"></a><em>%cE</em> </dt>
<dd>
<p>提交者电子邮箱（尊重 .mailmap，参见 <a href='{{< relurl "docs/git-shortlog/zh_HANS-CN" >}}'>git-shortlog[1]</a> 或 <a href='{{< relurl "docs/git-blame/zh_HANS-CN" >}}'>git-blame[1]</a></p>
</dd>
<dt class="hdlist1" id="git-log-emclem"> <a class="anchor" href="#git-log-emclem"></a><em>%cl</em> </dt>
<dd>
<p>提交者电子邮件的本地部分（<em>@</em> 符号之前的部分）</p>
</dd>
<dt class="hdlist1" id="git-log-emcLem"> <a class="anchor" href="#git-log-emcLem"></a><em>%cL</em> </dt>
<dd>
<p>提交者本地部分（参见'%cl' ）尊重 .mailmap, 参见 <a href='{{< relurl "docs/git-shortlog/zh_HANS-CN" >}}'>git-shortlog[1]</a> 或 <a href='{{< relurl "docs/git-blame/zh_HANS-CN" >}}'>git-blame[1]</a>)</p>
</dd>
<dt class="hdlist1" id="git-log-emcdem"> <a class="anchor" href="#git-log-emcdem"></a><em>%cd</em> </dt>
<dd>
<p>承诺人日期（格式尊重&#8212;&#8203;date=选项</p>
</dd>
<dt class="hdlist1" id="git-log-emcDem"> <a class="anchor" href="#git-log-emcDem"></a><em>%cD</em> </dt>
<dd>
<p>承诺人日期，RFC2822风格</p>
</dd>
<dt class="hdlist1" id="git-log-emcrem"> <a class="anchor" href="#git-log-emcrem"></a><em>%cr</em> </dt>
<dd>
<p>承诺人日期，相对</p>
</dd>
<dt class="hdlist1" id="git-log-emctem"> <a class="anchor" href="#git-log-emctem"></a><em>%ct</em> </dt>
<dd>
<p>提交者日期，UNIX时间戳</p>
</dd>
<dt class="hdlist1" id="git-log-emciem"> <a class="anchor" href="#git-log-emciem"></a><em>%ci</em> </dt>
<dd>
<p>承诺人日期，类似ISO 8601的格式</p>
</dd>
<dt class="hdlist1" id="git-log-emcIem"> <a class="anchor" href="#git-log-emcIem"></a><em>%cI</em> </dt>
<dd>
<p>承诺人日期，严格的ISO 8601格式</p>
</dd>
<dt class="hdlist1" id="git-log-emcsem"> <a class="anchor" href="#git-log-emcsem"></a><em>%cs</em> </dt>
<dd>
<p>承诺人日期，短格式（ <code>YYYY-MM-DD</code> ）</p>
</dd>
<dt class="hdlist1" id="git-log-emchem"> <a class="anchor" href="#git-log-emchem"></a><em>%ch</em> </dt>
<dd>
<p>提交者的日期，人类风格（就像 <a href='{{< relurl "docs/git-rev-list/zh_HANS-CN" >}}'>git-rev-list[1]</a> 的 <code>--date=human</code> 选项）</p>
</dd>
<dt class="hdlist1" id="git-log-emdem"> <a class="anchor" href="#git-log-emdem"></a><em>%d</em> </dt>
<dd>
<p>ref名称，就像<a href='{{< relurl "docs/git-log/zh_HANS-CN" >}}'>git-log[1]</a>的&#8212;&#8203;decorate选项。</p>
</dd>
<dt class="hdlist1" id="git-log-emDem"> <a class="anchor" href="#git-log-emDem"></a><em>%D</em> </dt>
<dd>
<p>没有"（"、"）"包装的参考文献名称。</p>
</dd>
<dt class="hdlist1" id="git-log-emdecorateltgtem"> <a class="anchor" href="#git-log-emdecorateltgtem"></a><em>%(decorate[:&lt;选项&gt;])</em> </dt>
<dd>
<p>自定义装饰的引用名称。<code>decorate</code> 字符串后面可以是冒号和零个或多个以逗号分隔的选项。选项值可能包含字面格式化代码。由于逗号（<code>%x2C</code>）和结尾括号（<code>%x29</code>）在选项语法中的作用，因此必须使用这些代码。</p>
<div class="ulist">
<ul>
<li>
<p><em>prefix=&lt;值&gt;</em>： 显示在引用名称列表之前。 默认为 "&#160;<code>(</code>"。</p>
</li>
<li>
<p><em>suffix=&lt;值&gt;</em>： 显示在引用名称列表之后。 默认为 "<code>)</code>"。</p>
</li>
<li>
<p><em>separator=&lt;值&gt;</em>： 显示在引用名称之间。 默认为 "<code>,</code>&#160;"。</p>
</li>
<li>
<p><em>point=&lt;值&gt;</em>： 显示在 HEAD 和其指向的分支（如果有）之间。
默认为 "&#160;<code>-&gt;</code>&#160;"。</p>
</li>
<li>
<p><em>tag=&lt;值&gt;</em>： 显示在标记名称之前。默认为 "<code>tag:</code>&#160;"。</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>例如，制作不带包装或标签注释的装饰，并用空格作为分隔符：</p>
</div>
<div class="paragraph">
<p>+
<code>%(decorate:prefix=,suffix=,tag=,separator= )</code></p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-log-emdescribeltgtem"> <a class="anchor" href="#git-log-emdescribeltgtem"></a><em>%(describe[:&lt;选项&gt;])</em> </dt>
<dd>
<p>人类可读的名字，像<a href='{{< relurl "docs/git-describe/zh_HANS-CN" >}}'>git-describe[1]</a>；空字符串表示不可描述的提交。 `describe`字符串后面可以有冒号和零个或多个逗号分隔的选项。 当标签同时被添加或删除时，描述可能不一致。</p>
<div class="ulist">
<ul>
<li>
<p><em>tags[=&lt;bool-value&gt;]</em>：不仅考虑带注释的标签，还考虑轻量级标签。</p>
</li>
<li>
<p><em>abbrev=&lt;数量&gt;</em>：不使用缩写对象名称的默认十六进制位数（根据仓库中对象的数量而变化，默认为 7 位），而是使用 &lt;数量&gt; 的位数，或根据需要的位数来组成唯一的对象名称。</p>
</li>
<li>
<p><em>match=&lt;pattern&gt;</em>:只考虑与给定的`glob(7)`模式匹配的标签，不包括 "refs/tags/"前缀。</p>
</li>
<li>
<p><em>exclude=&lt;pattern&gt;</em>:不考虑匹配给定`glob(7)`模式的标签，排除 "refs/tags/"前缀。</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1" id="git-log-emSem"> <a class="anchor" href="#git-log-emSem"></a><em>%S</em> </dt>
<dd>
<p>在命令行中给出的提交名称（如 <code>git log --source</code>），只对 <code>git log</code> 起作用</p>
</dd>
<dt class="hdlist1" id="git-log-emeem"> <a class="anchor" href="#git-log-emeem"></a><em>%e</em> </dt>
<dd>
<p>编码方式</p>
</dd>
<dt class="hdlist1" id="git-log-emsem"> <a class="anchor" href="#git-log-emsem"></a><em>%s</em> </dt>
<dd>
<p>主题</p>
</dd>
<dt class="hdlist1" id="git-log-emfem"> <a class="anchor" href="#git-log-emfem"></a><em>%f</em> </dt>
<dd>
<p>经过消毒的主题行，适合于文件名</p>
</dd>
<dt class="hdlist1" id="git-log-embem"> <a class="anchor" href="#git-log-embem"></a><em>%b</em> </dt>
<dd>
<p>正文</p>
</dd>
<dt class="hdlist1" id="git-log-emBem"> <a class="anchor" href="#git-log-emBem"></a><em>%B</em> </dt>
<dd>
<p>原始体（未包装的主题和体）</p>
</dd>
<dt class="hdlist1" id="git-log-emNem"> <a class="anchor" href="#git-log-emNem"></a><em>%N</em> </dt>
<dd>
<p>承诺说明</p>
</dd>
<dt class="hdlist1" id="git-log-emGGem"> <a class="anchor" href="#git-log-emGGem"></a><em>%GG</em> </dt>
<dd>
<p>来自GPG的签名提交的原始验证信息</p>
</dd>
<dt class="hdlist1" id="git-log-emGem"> <a class="anchor" href="#git-log-emGem"></a><em>%G?</em> </dt>
<dd>
<p>显示 "G" 代表一个好的（有效的）签名，"B" 代表一个坏的签名，"U" 代表一个有效性未知的好的签名，"X" 代表一个已经过期的好的签名，"Y" 代表一个由过期的钥匙制作的好的签名，"R" 代表一个由撤销的 钥匙制作的好的签名，"E" 如果不能检查签名（如缺少钥匙），"N" 代表没有签名</p>
</dd>
<dt class="hdlist1" id="git-log-emGSem"> <a class="anchor" href="#git-log-emGSem"></a><em>%GS</em> </dt>
<dd>
<p>显示已签名的提交的签名者的名字</p>
</dd>
<dt class="hdlist1" id="git-log-emGKem"> <a class="anchor" href="#git-log-emGKem"></a><em>%GK</em> </dt>
<dd>
<p>显示用于签署已签名的承诺的密钥</p>
</dd>
<dt class="hdlist1" id="git-log-emGFem"> <a class="anchor" href="#git-log-emGFem"></a><em>%GF</em> </dt>
<dd>
<p>显示用于签署已签名提交文件的密钥的指纹</p>
</dd>
<dt class="hdlist1" id="git-log-emGPem"> <a class="anchor" href="#git-log-emGPem"></a><em>%GP</em> </dt>
<dd>
<p>显示主键的指纹，该主键的子键被用来签署一个已签署的提交</p>
</dd>
<dt class="hdlist1" id="git-log-emGTem"> <a class="anchor" href="#git-log-emGTem"></a><em>%GT</em> </dt>
<dd>
<p>显示用于签署已签名的承诺的密钥的信任级别</p>
</dd>
<dt class="hdlist1" id="git-log-emgDem"> <a class="anchor" href="#git-log-emgDem"></a><em>%gD</em> </dt>
<dd>
<p>reflog选择器，例如，<code>refs/stash@{1}`或`refs/stash@{2分钟前}</code>；其格式遵循`-g`选项的规则。<code>@'前面的部分是命令行上给出的参考文献名称（所以`git log -g refs/heads/master`会产生`refs/heads/master@{0}</code>）。</p>
</dd>
<dt class="hdlist1" id="git-log-emgdem"> <a class="anchor" href="#git-log-emgdem"></a><em>%gd</em> </dt>
<dd>
<p>简化的 reflog 选择器；与 <code>%gD</code> 相同，但 refname 部分被缩短以利于人类阅读（因此 <code>refs/heads/master</code> 变成了 <code>master</code>）。</p>
</dd>
<dt class="hdlist1" id="git-log-emgnem"> <a class="anchor" href="#git-log-emgnem"></a><em>%gn</em> </dt>
<dd>
<p>记录身份名称</p>
</dd>
<dt class="hdlist1" id="git-log-emgNem"> <a class="anchor" href="#git-log-emgNem"></a><em>%gN</em> </dt>
<dd>
<p>引用日志身份名称（尊重 .mailmap，参见 <a href='{{< relurl "docs/git-shortlog/zh_HANS-CN" >}}'>git-shortlog[1]</a> 或 <a href='{{< relurl "docs/git-blame/zh_HANS-CN" >}}'>git-blame[1]</a></p>
</dd>
<dt class="hdlist1" id="git-log-emgeem"> <a class="anchor" href="#git-log-emgeem"></a><em>%ge</em> </dt>
<dd>
<p>重新记录身份邮件</p>
</dd>
<dt class="hdlist1" id="git-log-emgEem"> <a class="anchor" href="#git-log-emgEem"></a><em>%gE</em> </dt>
<dd>
<p>引用日志身份电子邮箱（尊重 .mailmap，参见 <a href='{{< relurl "docs/git-shortlog/zh_HANS-CN" >}}'>git-shortlog[1]</a> 或 <a href='{{< relurl "docs/git-blame/zh_HANS-CN" >}}'>git-blame[1]</a></p>
</dd>
<dt class="hdlist1" id="git-log-emgsem"> <a class="anchor" href="#git-log-emgsem"></a><em>%gs</em> </dt>
<dd>
<p>记录主题</p>
</dd>
<dt class="hdlist1" id="git-log-emtrailersltgtem"> <a class="anchor" href="#git-log-emtrailersltgtem"></a><em>%(trailers[:&lt;选项&gt;])</em> </dt>
<dd>
<p>显示由 <a href='{{< relurl "docs/git-interpret-trailers/zh_HANS-CN" >}}'>git-interpret-trailers[1]</a> 解释的正文的为主。<code>trailers</code> 字符串后面可以有冒号和零个或多个逗号分隔的选项。 如果任何选项被多次提供，则最后出现的选项获胜。</p>
<div class="ulist">
<ul>
<li>
<p><em>key=&lt;键&gt;</em>：只显示具有指定密钥的为主。匹配是不分大小写的，后面的冒号是可选的。如果多次给出选项，则显示与任何键匹配的为主行。该选项自动启用 <code>only</code> 选项，使拖车块中的非尾注行被隐藏。如果不希望这样，可以用 <code>only=false</code> 禁用。 例如，<code>%(trailers:key=Reviewed-by)</code> 显示键为 <code>Reviewed-by</code> 的拖车行。</p>
</li>
<li>
<p><em>only[=&lt;布尔值&gt;]</em> ：选择是否应该包括来自尾注块的非尾注行。</p>
</li>
<li>
<p><em>separator=&lt;sep&gt;</em>: specify the separator inserted between trailer lines. Defaults to a line feed character. The string &lt;sep&gt; may contain the literal formatting codes described above. To use comma as separator one must use <code>%x2C</code> as it would otherwise be parsed as next option. E.g., <code>%(trailers:key=Ticket,separator=%x2C )</code> shows all trailer lines whose key is "Ticket" separated by a comma and a space.</p>
</li>
<li>
<p><em>unfold[=&lt;布尔值&gt;]</em>：使它的行为就像 interpret-trailer 的 <code>--unfold</code> 选项被给出一样。例如，`%(trailers:only,unfold=true)`会展开并显示所有的尾注行。</p>
</li>
<li>
<p><em>keyonly[=&lt;布尔值&gt;]</em>：只显示尾注的关键部分。</p>
</li>
<li>
<p><em>valueonly[=&lt;布尔值&gt;]</em>：只显示尾注的值部分。</p>
</li>
<li>
<p><em>key_value_separator=&lt;sep&gt;</em>: specify the separator inserted between the key and value of each trailer. Defaults to ": ". Otherwise it shares the same semantics as <em>separator=&lt;sep&gt;</em> above.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
一些占位符可能取决于给修订版遍历引擎的其他选项。例如，<code>%g*</code> reflog选项将插入一个空字符串，除非我们正在遍历reflog条目（例如，通过`git log -g`）。<code>%d`和</code>%D`占位符将使用 "短 "装饰格式，如果`--decorate`没有在命令行上提供。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The boolean options accept an optional value <code>[=&lt;bool-value&gt;]</code>. The values taken by <code>--type=bool</code> git-config[1], like <code>yes</code> and <code>off</code>, are all accepted. Giving a boolean option without <code>=&lt;value&gt;</code> is equivalent to giving it with <code>=true</code>.</p>
</div>
<div class="paragraph">
<p>如果你在占位符的'%<em>后面加了一个`+</em>（加号），当且仅当占位符扩展为一个非空字符串时，在扩展前会立即插入换行符。</p>
</div>
<div class="paragraph">
<p>如果你在占位符的'%<em>后面加了一个`-</em>（减号），如果且仅当占位符扩展为空字符串时，紧接着扩展前的所有连续换行将被删除。</p>
</div>
<div class="paragraph">
<p>如果你在占位符的'%'后面加了一个``（空格），当且仅当占位符扩展到一个非空字符串时，空格就会紧接着插入扩展。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>t格式:</em></p>
<div class="paragraph">
<p><em>tformat:</em> 格式的工作原理与 <em>format:</em> 完全一样，只是它提供了 “终止符” 语义，而不是 “分隔符” 语义。换句话说，每个提交都附加了信息结束符（通常是换行符），而不是在条目之间放置一个分隔符。 这意味着单行格式的最后一个条目将正确地以新行结束，就像 “单行” 格式那样。 比如说：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git log -2 --pretty=format:%h 4da45bef \
  | perl -pe '$_ .= " -- NO NEWLINE\n" unless /\n/'
4da45be
7134973 -- NO NEWLINE

$ git log -2 --pretty=tformat:%h 4da45bef \
  | perl -pe '$_ .= " -- NO NEWLINE\n" unless /\n/'
4da45be
7134973</pre>
</div>
</div>
<div class="paragraph">
<p>此外，任何未被识别的字符串，如果其中有 <code>%</code> ，将被解释为前面有 <code>tformat:</code> 。 例如，这两个是等同的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git log -2 --pretty=tformat:%h 4da45bef
$ git log -2 --pretty=%h 4da45bef</pre>
</div>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_差异格式化"><a class="anchor" href="#_差异格式化"></a>差异格式化</h2>
<div class="sectionbody">
<div class="paragraph">
<p>默认情况下，`git log`不会产生任何差异输出。下面的选项可以用来显示每次提交所做的修改。</p>
</div>
<div class="paragraph">
<p>请注意，除非明确给出了 <code>--diff-merges</code> 变体（包括短 <code>-m</code>、<code>-c</code>、<code>--cc</code> 和 <code>--dd</code> 选项），否则合并提交不会显示差异，即使选择了 <code>--patch</code> 等差异格式，也不会匹配 <code>-S</code> 等搜索选项。使用 <code>--first-parent</code> 时例外，在这种情况下，<code>--first-parent</code> 是合并提交的默认格式。</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="paragraph">
<p>Missing <code>zh_HANS-CN/diff-options.adoc</code></p>
</div>
<div class="paragraph">
<p>See original version for this content.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="generate_patch_text_with_p"><a class="anchor" href="#generate_patch_text_with_p"></a>使用选项 <code>-p</code> 生成补丁文本</h2>
<div class="sectionbody">
<div class="paragraph">
<p>使用 <code>-p</code> 选项运行 <a href='{{< relurl "docs/git-diff/zh_HANS-CN" >}}'>git-diff[1]</a>、<a href='{{< relurl "docs/git-log/zh_HANS-CN" >}}'>git-log[1]</a>、<a href='{{< relurl "docs/git-show/zh_HANS-CN" >}}'>git-show[1]</a>、<a href='{{< relurl "docs/git-diff-index/zh_HANS-CN" >}}'>git-diff-index[1]</a>、<a href='{{< relurl "docs/git-diff-tree/zh_HANS-CN" >}}'>git-diff-tree[1]</a> 或 <a href='{{< relurl "docs/git-diff-files/zh_HANS-CN" >}}'>git-diff-files[1]</a> 会生成补丁文本。 你可以通过 <code>GIT_EXTERNAL_DIFF</code> 和 <code>GIT_DIFF_OPTS</code> 环境变量（参见 <a href='{{< relurl "docs/git/zh_HANS-CN" >}}'>git[1]</a>），以及 <code>diff</code> 属性（参见 <a href='{{< relurl "docs/gitattributes/zh_HANS-CN" >}}'>gitattributes[5]</a>）自定义补丁文本的创建。</p>
</div>
<div class="paragraph">
<p>What the <code>-p</code> option produces is slightly different from the traditional diff format:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>它前面有一个 <code>git diff</code> 头，如下所示：</p>
<div class="literalblock">
<div class="content">
<pre>diff --git a/file1 b/file2</pre>
</div>
</div>
<div class="paragraph">
<p><code>a/</code> 和 <code>b/</code> 的文件名相同，除非涉及到重命名/复制。特别地，即使是创建或删除，也 <em>不</em> 使用 <code>/dev/null</code> 来代替 <code>a/</code> 或 <code>b/</code> 文件名。</p>
</div>
<div class="paragraph">
<p>当涉及重命名/复制时，<code>file1</code> 和 <code>file2</code> 分别显示重命名/复制的源文件名和重命名/复制产生的文件名。</p>
</div>
</li>
<li>
<p>它的后面是一个或多个扩展头信息行：</p>
<div class="paragraph">
<p>old mode &lt;mode&gt;
new mode &lt;mode&gt;
deleted file mode &lt;mode&gt;
new file mode &lt;mode&gt;
copy from &lt;path&gt;
copy to &lt;path&gt;
rename from &lt;path&gt;
rename to &lt;path&gt;
similarity index &lt;number&gt;
dissimilarity index &lt;number&gt;
index &lt;hash&gt;..&lt;hash&gt; &lt;mode&gt;</p>
</div>
<div class="paragraph">
<p>File modes <em>&lt;mode&gt;</em> are printed as 6-digit octal numbers including the file type and file permission bits.</p>
</div>
<div class="paragraph">
<p>扩展头信息中的路径名称不包括 <code>a/</code> 和 <code>b/</code> 前缀。</p>
</div>
<div class="paragraph">
<p>相似性指数是未改变的行占比，而不相似性指数是改变的行占比。它是四舍五入的整数，后有百分号。因此，100%的相似度指数指为两个文件相等，而 100% 的不相似度意味着入新文件中没有旧文件中的行。</p>
</div>
<div class="paragraph">
<p>The index line includes the blob object names before and after the change. The <em>&lt;mode&gt;</em> is included if the file mode does not change; otherwise, separate lines indicate the old and the new mode.</p>
</div>
</li>
<li>
<p>含有 "不常见" 字符的路径名会被引用，这一点在配置变量` core.quotePath` 中有所解释（见 <a href='{{< relurl "docs/git-config/zh_HANS-CN" >}}'>git-config[1]</a>）。</p>
</li>
<li>
<p>输出中所有的 <code>file1</code> 文件都是指提交前的文件，而所有的 <code>file2</code> 文件都是指提交后的文件。按顺序对每个文件进行修改是不正确的。例如，这个补丁将交换文件 a 和 b：</p>
<div class="literalblock">
<div class="content">
<pre>diff --git a/a b/b
rename from a
rename to b
diff --git a/b b/a
rename from b
rename to a</pre>
</div>
</div>
</li>
<li>
<p>块头提到了块头所适用的函数的名称。 参见 <a href='{{< relurl "docs/gitattributes/zh_HANS-CN" >}}'>gitattributes[5]</a> 中的 “定义自定义 hunk-header”，以了解如何针对特定语言进行定制。</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_合并的差异格式"><a class="anchor" href="#_合并的差异格式"></a>合并的差异格式</h2>
<div class="sectionbody">
<div class="paragraph">
<p>任何生成差异的命令都可以使用 <code>-c</code> 或 <code>--cc</code> 选项，在显示合并时产生一个 “合并差异”。当用 <a href='{{< relurl "docs/git-diff/zh_HANS-CN" >}}'>git-diff[1]</a> 或 <a href='{{< relurl "docs/git-show/zh_HANS-CN" >}}'>git-show[1]</a> 显示合并时，这默认格式。还需要注意的是，你可以给这些命令适当的 <code>--diff-merges</code> 选项来强制生成特定格式的差异。</p>
</div>
<div class="paragraph">
<p>"合并的差异" 的格式如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>diff --combined describe.c
index fabadb8,cc95eb0..4866510
--- a/describe.c
+++ b/describe.c
@@@ -98,20 -98,12 +98,20 @@@
	return (a_date &gt; b_date) ? -1 : (a_date == b_date) ? 0 : 1;
  }

- static void describe(char *arg)
 -static void describe(struct commit *cmit, int last_one)
++static void describe(char *arg, int last_one)
  {
 +	unsigned char sha1[20];
 +	struct commit *cmit;
	struct commit_list *list;
	static int initialized = 0;
	struct commit_name *n;

 +	if (get_sha1(arg, sha1) &lt; 0)
 +		usage(describe_usage);
 +	cmit = lookup_commit_reference(sha1);
 +	if (!cmit)
 +		usage(describe_usage);
 +
	if (!initialized) {
		initialized = 1;
		for_each_ref(get_name);</pre>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>它前面有 "git diff" 头，如下（当使用 <code>-c</code> 选项时）：</p>
<div class="literalblock">
<div class="content">
<pre>diff --combined file</pre>
</div>
</div>
<div class="paragraph">
<p>或如下（当使用 <code>--cc</code> 选项时）：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>diff --cc file</pre>
</div>
</div>
</li>
<li>
<p>它的后面是一个或多个扩展头信息行（本例显示的是与两个父提交的合并）：</p>
<div class="paragraph">
<p>index &lt;hash&gt;,&lt;hash&gt;..&lt;hash&gt;
mode &lt;mode&gt;,&lt;mode&gt;<code>..</code>&lt;mode&gt;
new file mode &lt;mode&gt;
deleted file mode &lt;mode&gt;,&lt;mode&gt;</p>
</div>
<div class="paragraph">
<p>The <code>mode &lt;mode&gt;,&lt;mode&gt;..&lt;mode&gt;</code> line appears only if at least one of the &lt;mode&gt; is different from the rest. Extended headers with information about detected content movement (renames and copying detection) are designed to work with the diff of two <em>&lt;tree-ish&gt;</em> and are not used by combined diff format.</p>
</div>
</li>
<li>
<p>它的后面是两行源文件/目标文件的头信息：</p>
<div class="literalblock">
<div class="content">
<pre>--- a/file
+++ b/file</pre>
</div>
</div>
<div class="paragraph">
<p>与传统 ‘统一’ diff 格式的双行标题类似，<code>/dev/null</code> 用于表示已创建或已删除的文件。</p>
</div>
<div class="paragraph">
<p>但是，如果提供了 --combined-all-paths 选项，你就会得到一个 N+1 行的源文件/目标文件头，其中 N 是合并提交中的父提交数量：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>--- a/file
--- a/file
--- a/file
+++ b/file</pre>
</div>
</div>
<div class="paragraph">
<p>如果重命名或复制检测处于活动状态，这种扩展格式可能很有用，可以让你在不同的父提交中看到文件的原始名称。</p>
</div>
</li>
<li>
<p>修改了文件块头信息的格式，以防止不小心将其送入 <code>patch -p1</code>。合并的差异格式是为审查合并提交的修改而创建的，并不是为了应用。这个变化类似于扩展的 "索引" 头信息的变化：</p>
<div class="literalblock">
<div class="content">
<pre>@@@ &lt;from-file-range&gt; &lt;from-file-range&gt; &lt;to-file-range&gt; @@@</pre>
</div>
</div>
<div class="paragraph">
<p>块中有（父提交数量+1）<code>@</code> 字符，用于合并的差异格式。</p>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>与传统的 "统一" 差异格式不同，这种格式显示两个文件 A 和 B 的列，其中有 <code>-</code>（减号&#8201;&#8212;&#8201;在 A 中出现，但在 B 中删除），<code>+</code>（加号&#8201;&#8212;&#8201;在 A 中缺少，但在 B 中增加），或 <code>" "</code>（空格&#8201;&#8212;&#8201;不变）前缀，这种格式比较两个或多个文件与一个文件 X，并显示 X 与其中每个文件的差异。文件中的每一个都有一列被前置在输出行中，以指出 X 的行与它的不同之处。</p>
</div>
<div class="paragraph">
<p>第 N 列中的 <code>-</code> 字符意味着该行出现在文件 N 中，但它没有出现在结果文件中。第 N 列中的 <code>+</code> 字符意味着该行出现在结果文件中，而文件 N 中没有该行（换句话说，从该父提交的角度来看，该行是被添加的）。</p>
</div>
<div class="paragraph">
<p>在上面的输出示例中，两个文件中的函数签名都被改变了（因此从文件 1 和文件 2 中都有表示删除的 <code>-</code>，而 <code>++</code> 表示被添加的一行没有出现在文件 1 或文件 2 中）。另外还有 8 行与文件 1 中的相同，但没有出现在文件 2 中（因此前缀为 <code>+</code>）。</p>
</div>
<div class="paragraph">
<p>当用 <code>git diff-tree -c</code> 显示时，它将合并提交的父提交文件与合并结果进行比较（即文件 1 &#8230;&#8203; 文件 N 是父提交文件）。当用 <code>git diff-files -c</code> 显示时，它将两个未解决的合并父提交文件与工作树文件进行比较（即文件 1 是阶段 2 ，又称 "我们的版本"，文件 2 是阶段 3，又称 "他们的版本"）。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_实例"><a class="anchor" href="#_实例"></a>实例</h2>
<div class="sectionbody">
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-log-codegitlog--no-mergescode"> <a class="anchor" href="#git-log-codegitlog--no-mergescode"></a><code>git log --no-merges</code> </dt>
<dd>
<p>显示整个提交历史，但跳过任何合并内容</p>
</dd>
<dt class="hdlist1" id="git-log-codegitlogv2612includescsidriversscsicode"> <a class="anchor" href="#git-log-codegitlogv2612includescsidriversscsicode"></a><code>git log v2.6.12.. include/scsi drivers/scsi</code> </dt>
<dd>
<p>显示自版本 <em>v2.6.12</em> 以来改变 <code>include/scsi</code> 或 <code>drivers/scsi</code> 子目录中任何文件的所有提交</p>
</dd>
<dt class="hdlist1" id="git-log-codegitlog--since2weeksago--gitkcode"> <a class="anchor" href="#git-log-codegitlog--since2weeksago--gitkcode"></a><code>git log --since="2 weeks ago" -- gitk</code> </dt>
<dd>
<p>显示过去两周内对文件 <em>gitk</em> 的修改。 <code>--</code> 是必要的，以避免与名为 <em>gitk</em> 的 <strong>分支</strong> 相混淆</p>
</dd>
<dt class="hdlist1" id="git-log-codegitlog--name-statusreleasetestcode"> <a class="anchor" href="#git-log-codegitlog--name-statusreleasetestcode"></a><code>git log --name-status release..test</code> </dt>
<dd>
<p>显示在 "test "分支中但尚未在 "release "分支中的提交，以及每个提交修改的路径列表。</p>
</dd>
<dt class="hdlist1" id="git-log-codegitlog--followbuiltinrev-listccode"> <a class="anchor" href="#git-log-codegitlog--followbuiltinrev-listccode"></a><code>git log --follow builtin/rev-list.c</code> </dt>
<dd>
<p>显示改变`builtin/rev-list.c`的提交，包括那些在文件被赋予现在名字之前发生的提交。</p>
</dd>
<dt class="hdlist1" id="git-log-codegitlog--branches--not--remotesorigincode"> <a class="anchor" href="#git-log-codegitlog--branches--not--remotesorigincode"></a><code>git log --branches --not --remotes=origin</code> </dt>
<dd>
<p>显示所有在本地分支中但不在 "origin "的远程跟踪分支中的提交（你有而origin没有的东西）。</p>
</dd>
<dt class="hdlist1" id="git-log-codegitlogmaster--not--remotesmastercode"> <a class="anchor" href="#git-log-codegitlogmaster--not--remotesmastercode"></a><code>git log master --not --remotes=*/master</code> </dt>
<dd>
<p>显示所有在本地主库但不在任何远程仓库主库分支中的提交。</p>
</dd>
<dt class="hdlist1" id="git-log-codegitlog-p-m--first-parentcode"> <a class="anchor" href="#git-log-codegitlog-p-m--first-parentcode"></a><code>git log -p -m --first-parent</code> </dt>
<dd>
<p>显示包括变化差异的历史，但只从 "主分支 "的角度，跳过来自合并分支的提交，并显示合并带来的全部变化差异。 这只有在遵循严格的政策，在停留在一个集成分支时合并所有主题分支时才有意义。</p>
</dd>
<dt class="hdlist1" id="git-log-codegitlog-Lintmainmainccode"> <a class="anchor" href="#git-log-codegitlog-Lintmainmainccode"></a><code>git log -L '/int main/',/^}/:main.c</code> </dt>
<dd>
<p>显示了文件`main.c`中的函数`main()`是如何随时间演变的。</p>
</dd>
<dt class="hdlist1" id="git-log-codegitlog-3code"> <a class="anchor" href="#git-log-codegitlog-3code"></a><code>git log -3</code> </dt>
<dd>
<p>将显示的提交数量限制在3个。</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_讨论"><a class="anchor" href="#_讨论"></a>讨论</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Git在某种程度上是与字符编码无关的。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>blob对象的内容是未经解释的字节序列。 在核心层没有编码转换。</p>
</li>
<li>
<p>路径名以UTF-8规范化形式C编码，这适用于树对象、索引文件、参考名称，以及命令行参数、环境变量和配置文件（<code>.git/config</code>（见<a href='{{< relurl "docs/git-config/zh_HANS-CN" >}}'>git-config[1]</a>），<a href='{{< relurl "docs/gitignore/zh_HANS-CN" >}}'>gitignore[5]</a>，<a href='{{< relurl "docs/gitattributes/zh_HANS-CN" >}}'>gitattributes[5]</a> 和<a href='{{< relurl "docs/gitmodules/zh_HANS-CN" >}}'>gitmodules[5]</a>）中的路径名。</p>
<div class="paragraph">
<p>请注意，Git 在核心层将路径名简单地视为非 NUL 字节的序列，没有路径名编码的转换（除了 Mac 和 Windows）。因此，即使在使用传统的扩展ASCII编码的平台和文件系统上，使用非ASCII的路径名大多也能工作。然而，在这种系统上创建的仓库在基于UTF-8的系统（如Linux、Mac、Windows）上将无法正常工作，反之亦然。 此外，许多基于Git的工具简单地认为路径名称是UTF-8，而不能正确显示其他编码。</p>
</div>
</li>
<li>
<p>提交日志信息通常以UTF-8编码，但也支持其他扩展ASCII编码。这包括ISO-8859-x、CP125x和其他许多编码，但不包括UTF-16/32、EBCDIC和CJK多字节编码（GBK、Shift-JIS、Big5、EUC-x、CP9xx等）。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>尽管我们鼓励提交日志信息使用UTF-8编码，但核心系统和Git Porcelain的设计并不强制要求项目使用UTF-8。 如果某个项目的所有参与者都认为使用传统编码更方便，Git也不会禁止。 然而，有几件事需要注意。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>git commit</code> and <code>git commit-tree</code> issue a warning if the commit log message given to it does not look like a valid UTF-8 string, unless you explicitly say your project uses a legacy encoding. The way to say this is to have <code>i18n.commitEncoding</code> in <code>.git/config</code> file, like this:</p>
<div class="listingblock">
<div class="content">
<pre>[i18n]
	commitEncoding = ISO-8859-1</pre>
</div>
</div>
<div class="paragraph">
<p>用上述设置创建的提交对象在它的 <code>encoding</code> 头中记录了 <code>i18n.commitEncoding</code> 的值。 这是为了帮助以后看这些对象的人。 缺少这个头意味着提交日志信息是以 UTF-8 编码的。</p>
</div>
</li>
<li>
<p><code>git log</code>, <code>git show</code>, <code>git blame</code> and friends look at the <code>encoding</code> header of a commit object, and try to re-code the log message into UTF-8 unless otherwise specified. You can specify the desired output encoding with <code>i18n.logOutputEncoding</code> in <code>.git/config</code> file, like this:</p>
<div class="listingblock">
<div class="content">
<pre>[i18n]
	logOutputEncoding = ISO-8859-1</pre>
</div>
</div>
<div class="paragraph">
<p>如果你没有这个配置变量，则使用`i18n.commitEncoding`的值来代替。</p>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>请注意，我们特意选择在提交对象层面上，不对提交日志信息进行重新编码，因为重新编码为UTF-8不一定是一个可逆的操作。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_配置"><a class="anchor" href="#_配置"></a>配置</h2>
<div class="sectionbody">
<div class="paragraph">
<p>核心变量见 <a href='{{< relurl "docs/git-config/zh_HANS-CN" >}}'>git-config[1]</a> ，与 diff 生成相关的设置见 <a href='{{< relurl "docs/git-diff/zh_HANS-CN" >}}'>git-diff[1]</a> 。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-log-formatpretty"> <a class="anchor" href="#git-log-formatpretty"></a>format.pretty </dt>
<dd>
<p>`--format`选项的默认值。 (见上面的 "漂亮的格式"。)默认为 "中等"。</p>
</dd>
<dt class="hdlist1" id="git-log-i18nlogOutputEncoding"> <a class="anchor" href="#git-log-i18nlogOutputEncoding"></a>i18n.logOutputEncoding </dt>
<dd>
<p>显示日志时要使用的编码。 (见上面的 "讨论"。)如果设置了，默认为`i18n.commitEncoding`的值，否则为UTF-8。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>本节中这一行以上的内容并不包括在 <a href='{{< relurl "docs/git-config/zh_HANS-CN" >}}'>git-config[1]</a> 文档中。下面的内容与那里的内容相同：</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="paragraph">
<p>Missing <code>zh_HANS-CN/config/log.adoc</code></p>
</div>
<div class="paragraph">
<p>See original version for this content.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="paragraph">
<p>Missing <code>zh_HANS-CN/config/notes.adoc</code></p>
</div>
<div class="paragraph">
<p>See original version for this content.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_git"><a class="anchor" href="#_git"></a>GIT</h2>
<div class="sectionbody">
<div class="paragraph">
<p>属于 <a href='{{< relurl "docs/git/zh_HANS-CN" >}}'>git[1]</a> 文档</p>
</div>
</div>
</div>